@ /eq root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 1920
  .height 1200
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1446
    #%graph.y -37
    .device 2
    .full-screen true
    .always-on-top true
    .undecorated true
    .show-cursor true
  }
  @ ./eq video:gl:p2d {
    #%graph.x 698
    #%graph.y -39
    .code "

    @P(1) @OnChange(\"processFFT\") float\[\] fftIn;
    @P(2) @Type.Number(def=0.2, min=0, max=1) double smoothing;
    
    @P(5) @Type.Number(def=0.4, min=0.0, max=2, skew=2) double recoil;
    
    float\[\] fft;
    int maxFFT;
    final int MAX_FREQ = 10910;
    
    @P(10) @ReadOnly int strobeFreq = Integer.MAX_VALUE;
    @P(11) @ReadOnly double strobePower = Double.MAX_VALUE; 
    @P(12) @ReadOnly int strobePowerAdjusted = Integer.MAX_VALUE;
    @P(13) @ReadOnly int strobeFreqBand = Integer.MAX_VALUE;
    
    @Out(0) Output ping;
    
    @Inject Property bgStrobe;
    @Inject Property fgStrobe;
    
    
    @Override
    public void setup() \{
        rectMode(CORNERS);
        ellipseMode(CENTER);
    \}

    void processFFT() \{
        if(null == fft) \{
            fft = fftIn;
        \}
        maxFFT = fftIn.length/2;
        float\[\] newFFT = new float\[maxFFT\];
        float s = (float) smoothing;
        try \{
            for (int i=0; i<maxFFT; ++i) \{
                newFFT\[i\] = fft\[i\]*s + fftIn\[i\]*(1-s);
            \}
        \} catch (ArrayIndexOutOfBoundsException e) \{
            
        \} finally \{
            fft = newFFT;
        \}
    \}
    

    @Override
    public void draw() \{
        if(null == fft || fft.length == 0 || 0 == maxFFT) \{
            log(WARNING, \"No signal\");
            return;
        \}
        strokeWeight(1);
        fill(255);
        stroke(255);
        boolean mouseHit = false;
        int eqWidth = width - 400;
        double bar = (width - 100)/(maxFFT);
        for(int i = 0; i<maxFFT; ++i) \{
            float amp = fft\[i\];
            double displayAmp = adjustPower(amp);
            double left = bar*i;
            double right = bar*i+bar;
            rect(left+1, height, right-1, height-displayAmp);
            if(left <= mouseX && right >= mouseX && displayAmp > height - mouseY) \{
                mouseHit = true;
            \}
            if(amp >= strobePower && i == strobeFreqBand && !bgStrobe.isAnimating()) \{
                bgStrobe.set(255).to(0).in(recoil).easeIn();
                ping.send();
            \}
        \}
        noStroke();
        fill(255, 0 , 0,i(bgStrobe));
        if(bgStrobe.isAnimating()) \{
            ellipse(strobeFreqBand * bar, height-strobePowerAdjusted, 100, 100);
        \}
        
        fill(255);
        text(String.format(\"FFT Bands: %d\", maxFFT), width - 100, height - 20);
        printFreqPowerInfo(width - 300, height - 300, strobeFreqBand, strobeFreq, strobePower, strobePowerAdjusted);
        
        strokeWeight(0.5);
        stroke(mouseHit ? 255 : 0, mouseHit ? 0 : 255, 0);
        if (pmouseX < eqWidth) \{
            line(pmouseX, 0, pmouseX, height);
            line(0, pmouseY, eqWidth, pmouseY);
            int freqBand = (int) (pmouseX / bar);
            int freq = (int) (MAX_FREQ * (double)pmouseX / eqWidth);
            int adjustedPowerMouse = height-pmouseY;
            double powerMouse = deAdjustPower(adjustedPowerMouse);
            
            printFreqPowerInfo(pmouseX, pmouseY, freqBand, freq, powerMouse, adjustedPowerMouse);
            if (mousePressed) \{
                strobeFreq = freq;
                strobePower = powerMouse;
                strobePowerAdjusted = adjustedPowerMouse;
                strobeFreqBand = freqBand;
            \}
        \}
    \}
    
    void printFreqPowerInfo(int leftX, int bottomY, int freqBand, int freq, double power, int adjustedPower) \{
        noStroke();
        fill(0, 60);
        rect(leftX + 2, bottomY - 2, leftX + 170, bottomY - 56);
        fill(0, 255, 0);
        text(String.format(\"Band:  %d\", freqBand), leftX + 5, bottomY - 44);
        text(String.format(\"Frequency:  ~%dHz\", freq), leftX + 5, bottomY - 31);
        text(String.format(\"Adjusted power:  %.0f\", power), leftX + 5, bottomY - 18);
        text(String.format(\"Raw power:  %dcans\", adjustedPower), leftX + 5, bottomY - 5);
    \}
    
    double adjustPower(double power) \{
        return (30.0 * log(power * 100.0));
    \}
    
    double deAdjustPower(double adjustedPower) \{
        return exp(adjustedPower/30.0)/100;
    \}
"
    .fft-in "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
40aUOgGLHTkpIHg7PTCLOOLjlDmo8KY="
    .smoothing 0.5
    .recoil 0.4002770083102493
  }
  @ ./voronoi-p2d video:gl:p2d {
    #%graph.x 1159
    #%graph.y 24
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PointD>> pointsRef;
    
    // Coordinates of cell vertices
    double\[\]\[\] vertices;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    
    
    // Initialisation

    @Override public void setup() \{
        initRefs();
        updateCellsInputs();
        updateCellsCount();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        pointsRef.init(CopyOnWriteArrayList::new);
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(
                    i,
                    ins\[inNo\], 
                    coloursRef.get().get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        pointsRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Arrays.asList(newPoints));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PointD point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        updateCellsGeometry();
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = pointsRef.get().get(i);
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                pointsRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved || vertices == null) \{
            recalculateVoronoiRegions();
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, cellsCount).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            double\[\] coords = vertices\[cell.no\];
            for(int i=0; i<coords.length/2; i+=1) \{
                double x = coords\[i*2\];
                double y = coords\[i*2+1\];
                vertex(x, y, x, y);
            \}
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<pointsRef.get().size(); ++i) \{
            PointD p = pointsRef.get().get(i);
            text(i, p.x, p.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}

    

    // Cell movement
    
    @T(1) public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        VoronoiResults results = Voronoi.findAll(pointsRef.get().toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        double\[\]\[\] newCoords = new double\[regions.length\]\[\];
        for(int i = 0; i<regions.length; ++i) \{
            newCoords\[i\] = PointD.toDoubles(regions\[i\]);
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        vertices = newCoords;
        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, PImage in, PVector colour, Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
"
    .movements All
    .movement-speed 10
    .time-to-move .4
    .cells-count 40
    .cells-inputs 3
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 6
    .draw-cells true
    .just-colours false
  }
  @ ./strobes core:container {
    #%graph.x 794
    #%graph.y 279
    #%praxis.version 4.1.1
    @ ./strobe-0 video:gl:p2d {
      #%graph.x 92
      #%graph.y -3
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-0 video:container:out {
      #%graph.x 1301
      #%graph.y -3
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x 232
      #%graph.y 47
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-1 video:container:out {
      #%graph.x 1301
      #%graph.y 47
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x 372
      #%graph.y 97
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-2 video:container:out {
      #%graph.x 1301
      #%graph.y 97
    }
    @ ./strobe-3 video:gl:p2d {
      #%graph.x 512
      #%graph.y 147
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-3 video:container:out {
      #%graph.x 1301
      #%graph.y 147
    }
    @ ./strobe-4 video:gl:p2d {
      #%graph.x 652
      #%graph.y 197
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-4 video:container:out {
      #%graph.x 1301
      #%graph.y 197
    }
    @ ./strobe-5 video:gl:p2d {
      #%graph.x 792
      #%graph.y 247
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-5 video:container:out {
      #%graph.x 1301
      #%graph.y 247
    }
    @ ./strobe-6 video:gl:p2d {
      #%graph.x 932
      #%graph.y 297
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease .2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-6 video:container:out {
      #%graph.x 1301
      #%graph.y 297
    }
    @ ./strobe-7 video:gl:p2d {
      #%graph.x 1072
      #%graph.y 347
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-7 video:container:out {
      #%graph.x 1301
      #%graph.y 347
    }
    @ ./in-0 core:container:in {
      #%graph.x -134
      #%graph.y -3
    }
    @ ./in-1 core:container:in {
      #%graph.x -134
      #%graph.y 47
    }
    @ ./in-2 core:container:in {
      #%graph.x -134
      #%graph.y 97
    }
    @ ./in-3 core:container:in {
      #%graph.x -134
      #%graph.y 147
    }
    @ ./in-4 core:container:in {
      #%graph.x -134
      #%graph.y 197
    }
    @ ./in-5 core:container:in {
      #%graph.x -134
      #%graph.y 247
    }
    @ ./in-6 core:container:in {
      #%graph.x -134
      #%graph.y 297
    }
    @ ./in-7 core:container:in {
      #%graph.x -134
      #%graph.y 347
    }
    ~ ./strobe-0!out ./out-0!in
    ~ ./strobe-1!out ./out-1!in
    ~ ./strobe-2!out ./out-2!in
    ~ ./strobe-3!out ./out-3!in
    ~ ./strobe-4!out ./out-4!in
    ~ ./strobe-5!out ./out-5!in
    ~ ./strobe-6!out ./out-6!in
    ~ ./strobe-7!out ./out-7!in
    ~ ./in-0!out ./strobe-0!strobe
    ~ ./in-1!out ./strobe-1!strobe
    ~ ./in-2!out ./strobe-2!strobe
    ~ ./in-3!out ./strobe-3!strobe
    ~ ./in-4!out ./strobe-4!strobe
    ~ ./in-5!out ./strobe-5!strobe
    ~ ./in-6!out ./strobe-6!strobe
    ~ ./in-7!out ./strobe-7!strobe
  }
  @ ./strobe-control core:timing:timer {
    #%graph.x 539
    #%graph.y 279
    .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(4) Output out4;
    @Out(5) Output out5;
    @Out(6) Output out6;
    @Out(7) Output out7;
    
    @T(0) public void strobe0() \{ out0.send(); \}
    @T(1) public void strobe1() \{ out1.send(); \}
    @T(2) public void strobe2() \{ out2.send(); \}
    @T(3) public void strobe3() \{ out3.send(); \}
    @T(4) public void strobe4() \{ out4.send(); \}
    @T(5) public void strobe5() \{ out5.send(); \}
    @T(6) public void strobe6() \{ out6.send(); \}
    @T(7) public void strobe7() \{ out7.send(); \}
    
"
  }
  @ ./trigger-splitter core:custom {
    #%graph.x 124
    #%graph.y -37
    .code "
    @P(0) @Type.Number(def=0) @ReadOnly Property counter;
    
    @Out(0) Output outEach;
    @Out(1) Output out1Of2;
    @Out(2) Output out2Of2;
    @Out(3) Output out1Of4;
    @Out(4) Output out2Of4;
    @Out(5) Output out3Of4;
    @Out(6) Output out4Of4;
    @Out(7) Output out1Of8;
    @Out(8) Output out2Of8;
    @Out(9) Output out3Of8;
    @Out(10) Output out4Of8;
    @Out(11) Output out5Of8;
    @Out(12) Output out6Of8;
    @Out(13) Output out7Of8;
    @Out(14) Output out8Of8;
    
    @T(0) void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch(count) \{
            case 0: out1Of2.send(); out1Of4.send(); out1Of8.send(); break;
            case 1: out2Of2.send(); out2Of4.send(); out2Of8.send(); break;
            case 2: out1Of2.send(); out3Of4.send(); out3Of8.send(); break;
            case 3: out2Of2.send(); out4Of4.send(); out4Of8.send(); break;
            case 4: out1Of2.send(); out1Of4.send(); out5Of8.send(); break;
            case 5: out2Of2.send(); out2Of4.send(); out6Of8.send(); break;
            case 6: out1Of2.send(); out3Of4.send(); out7Of8.send(); break;
            case 7: out2Of2.send(); out4Of4.send(); out8Of8.send(); break;
        \}
    \}
    
    @T(1) void reset() \{
        counter.set(0);
    \}
"
  }
  ~ ./strobe-control!out-0 ./strobes!in-0
  ~ ./strobe-control!out-1 ./strobes!in-1
  ~ ./strobe-control!out-2 ./strobes!in-2
  ~ ./strobe-control!out-3 ./strobes!in-3
  ~ ./strobe-control!out-4 ./strobes!in-4
  ~ ./strobe-control!out-5 ./strobes!in-5
  ~ ./strobe-control!out-6 ./strobes!in-6
  ~ ./strobe-control!out-7 ./strobes!in-7
  ~ ./trigger-splitter!out-each ./strobe-control!strobe-0
  ~ ./trigger-splitter!out-2-of-2 ./strobe-control!strobe-1
  ~ ./voronoi-p2d!out ./screen!in
  ~ ./eq!ping ./trigger-splitter!trigger
  ~ ./trigger-splitter!out-1-of-2 ./voronoi-p2d!move-cells
  ~ ./strobes!out-0 ./voronoi-p2d!in-edges
  ~ ./strobes!out-1 ./voronoi-p2d!in-0
  ~ ./eq!out ./screen!in
}
