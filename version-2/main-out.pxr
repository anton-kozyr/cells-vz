@ /main-out root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 1920
  .height 1200
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1277
    #%graph.y 252
    .device 2
    .full-screen true
    .undecorated true
    .show-cursor true
  }
  @ ./strobe-timer core:timing:timer {
    #%graph.x -271
    #%graph.y 269
    .period 0.1
  }
  @ ./voronoi-renderer video:gl:p2d {
    #%graph.x 640
    #%graph.y 1
    .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
    .cells-inputs 2
    .edge-width 0.0
    .draw-cells true
  }
  @ ./xfader-1 video:xfader {
    #%graph.x 1067
    #%graph.y 202
    .mix 0.8326089465925318
  }
  @ ./white video:gl:p2d {
    #%graph.x 357
    #%graph.y 435
    .code "

    @Override
    public void setup() \{
        fill(255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./looper core:timing:animator {
    #%graph.x 1004
    #%graph.y 462
    .code "

    @P(1) @Type.Number @ReadOnly
    Property value;
    @P(2) @Type.Number(def = 0)
    double time;
    
    @Out(1) Output out;
    
    @Override
    public void init() \{
        if(value.getInt() < 0.5) \{
            value.to(1).in(time).easeInOut().whenDone(p -> init());
        \} else \{
            value.to(0).in(time).easeInOut().whenDone(p -> init());
        \}
    \}
    
    @Override
    public void update() \{
        out.send(d(value));
    \}
"
    .time 4
  }
  @ ./voronoi-renderer1 video:gl:p2d {
    #%graph.x 666
    #%graph.y 485
    .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
    .cells-inputs 5
    .edge-width 16.652178931850635
    .draw-cells true
    .just-colours false
  }
  @ ./voronoi-generator core:custom {
    #%graph.x -3
    #%graph.y 269
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.io.DataOutputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;

    @P(11) @Type.Integer(def=800) int width;
    @P(12) @Type.Integer(def=600) int height;
    
    @Out(100) Data.Out<PBytes> voronoiPipeOut;
    @Out(101) Output voronoiOut;
    
    List<Cell> cells = new ArrayList<>();
    
    // Cache of the encoded data to send
    PBytes voronoiBytes;
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x,
            m40x, m41x, m42x, m43x, m44x, m45x, m46x, m47x, m48x, m49x,
            m50x, m51x, m52x, m53x, m54x, m55x, m56x, m57x, m58x, m59x,
            m60x, m61x, m62x, m63x, m64x, m65x, m66x, m67x, m68x, m69x,
            m70x, m71x, m72x, m73x, m74x, m75x, m76x, m77x, m78x, m79x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y,
            m40y, m41y, m42y, m43y, m44y, m45y, m46y, m47y, m48y, m49y,
            m50y, m51y, m52y, m53y, m54y, m55y, m56y, m57y, m58y, m59y,
            m60y, m61y, m62y, m63y, m64y, m65y, m66y, m67y, m68y, m69y,
            m70y, m71y, m72y, m73y, m74y, m75y, m76y, m77y, m78y, m79y;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::encodeVoronoiData), voronoiPipeOut);
    \}

    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\},
            \{m40x, m40y\}, \{m41x, m41y\}, \{m42x, m42y\}, \{m43x, m43y\}, \{m44x, m44y\}, 
            \{m45x, m45y\}, \{m46x, m46y\}, \{m47x, m47y\}, \{m48x, m48y\}, \{m49x, m49y\},
            \{m50x, m50y\}, \{m51x, m51y\}, \{m52x, m52y\}, \{m53x, m53y\}, \{m54x, m54y\}, 
            \{m55x, m55y\}, \{m56x, m56y\}, \{m57x, m57y\}, \{m58x, m58y\}, \{m59x, m59y\},
            \{m60x, m60y\}, \{m61x, m61y\}, \{m62x, m62y\}, \{m63x, m63y\}, \{m64x, m64y\}, 
            \{m65x, m65y\}, \{m66x, m66y\}, \{m67x, m67y\}, \{m68x, m68y\}, \{m69x, m69y\},
            \{m70x, m70y\}, \{m71x, m71y\}, \{m72x, m72y\}, \{m73x, m73y\}, \{m74x, m74y\}, 
            \{m75x, m75y\}, \{m76x, m76y\}, \{m77x, m77y\}, \{m78x, m78y\}, \{m79x, m79y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            newCells.add(new Cell(i, moves\[i\]\[0\], moves\[i\]\[1\]));
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();
            voronoiBytes = encodeVoronoiData();
        \}
        voronoiOut.send(voronoiBytes);
    \}

    // Cell movement
    
    @T(1)
    public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(-1000, -1000, width+1000, height+1000);
        List<PointD> centers = centresRef.get().subList(0, cellsCount).stream()
                .map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).polygon = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
    \}

    // Data encoded as following: 
    // int: cellsCount
    // for each cell:
    //   int: centre.x
    //   int: centre.y
    //   int: vertices count
    //   for each vertex:
    //     int: vertex.x
    //     int: vertex.y
    PBytes encodeVoronoiData() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(cellsCount);
            cells.subList(0, cellsCount).forEach(cell -> \{
                
            \});
            for(int i=0; i<cellsCount; ++i) \{
                PVector centre = centresRef.get().get(i);
                dos.writeDouble(centre.x);
                dos.writeDouble(centre.y);
                Cell cell = cells.get(i);
                dos.writeInt(cell.polygon.size());
                cell.polygon.forEach(v -> \{
                    try \{
                        dos.writeDouble(v.x);
                        dos.writeDouble(v.y);
                    \} catch (IOException ex) \{
                        throw new RuntimeException(ex);
                    \}
                \});
            \}
            dos.flush();
            PBytes bytes = os.toBytes();
            dos.close();
            return bytes;
        \} catch (Exception ex) \{
            log(ERROR, \"Voronoi data encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final Property moveX;
        final Property moveY;
        List<PVector> polygon;
        
        Cell(int no, Property moveX, Property moveY) \{
            this.no = no;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        PVector centre() \{
            return centresRef.get().get(no);
        \}
        
        List<PVector> polygon() \{
            return polygon;
        \}
    \}
"
    .movement-speed 10
    .time-to-move 3
    .cells-count 80
    .width 1920
    .height 1200
  }
  @ ./voronoi-attempt-to-shrink-manually video:gl:p2d {
    #%graph.x 1148
    #%graph.y 957
    .code "import org.locationtech.jts.geom.*;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    GeometryFactory geometryFactory = new GeometryFactory();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();

        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
        drawEdges();
    \}

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            Object centresObject = v.get(\"centres\");
            Object verticesObject = v.get(\"vertices\");
            if(centresObject instanceof List && verticesObject instanceof List) \{
                List<Cell> newCells = new ArrayList<>(cells);
                List<PVector> centres = (List<PVector>) centresObject;
                for(int i=0; i<centres.size(); ++i) \{
                    newCells.get(i).centre = centres.get(i);
                \}
                List<List<PVector>> vertices = (List<List<PVector>>) verticesObject;
                for(int i=0; i<vertices.size(); ++i) \{
                    updateEdges_custom(newCells.get(i), vertices.get(i));
                \}
                cells = newCells;
            \} else \{
                log(ERROR, \"Weird data received\");
            \}
        \}
    \}
    
    void updateEdges(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices || vertices.isEmpty()) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        final List<PVector> originalVertices = new ArrayList<>(vertices);
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        cell.vertices = Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}
    
    /**
     * Calculates inner polygons (removing edges)
     */
    void updateEdges_custom(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        int count = vertices.size();
        
        // push edges inside
        List<List<PVector>> edges = new ArrayList<>(count);
        for (int i=0; i<vertices.size(); ++i) \{
            PVector a = vertices.get(i);
            PVector b = vertices.get((i+1) % count);
            boolean verticalBorder = a.x == b.x && a.x % width < EDGE_THRESHOLD;
            boolean horisontalBorder = a.y == b.y && a.y % height < EDGE_THRESHOLD;
            if(verticalBorder || horisontalBorder) \{
                edges.add(Arrays.asList(a, b));
            \} else \{
                edges.add(moveEdge(a, b, cell.centre, edgeWidth/2)); 
            \}
        \}

        
        List<PVector> newVertices = verticesFromEdges(edges);
        
        cell.label = \"\" + count + \"\\n\";
        List<List<PVector>> cleanEdges = new ArrayList<>(count);
        // Clear self-intersection if found https://stackoverflow.com/a/7785719
        boolean previousBad = false;
        for (int i=-1; i<count; ++i) \{
            PVector na = newVertices.get((i+count-1) % count);
            PVector nb = newVertices.get((i+count) % count);
            PVector nc = newVertices.get((i+1) % count);
            PVector nba = na.copy().sub(nb);
            PVector nbc = nc.copy().sub(nb); 
            PVector nCross = nbc.copy().cross(nba);

            PVector oa = vertices.get((i+count-1) % count);
            PVector ob = vertices.get((i+count) % count);
            PVector oc = vertices.get((i+1) % count);
            PVector oba = oa.copy().sub(ob);
            PVector obc = oc.copy().sub(ob);
            PVector oCross = obc.copy().cross(oba);

            boolean bad = Math.signum(nCross.z) != Math.signum(oCross.z);
            if (i != -1) \{
                if(bad && !previousBad) \{
                    //cell.label += String.format(\"%.1f\\n\", nCross.z);
                    cell.label += \"-\\n\";
                    previousBad = true;
                \} else \{
                    cleanEdges.add(Arrays.asList(nb, nc));
                    cell.label += \"+\\n\";
                    previousBad = false;
                \}
            \} else \{
                previousBad = bad;
            \}

        \}
        newVertices = verticesFromEdges(cleanEdges);
        
        cell.vertices = newVertices.size() > 2 ? newVertices : Collections.emptyList();
    \}
    
    /**
     * Move edge towards centre https://stackoverflow.com/a/15187473
     * 
     * @param a first edge point
     * @param b second edge point
     * @param c centre
     * @param ew distance (edge half width)
     * @return two new points
     */
    List<PVector> moveEdge(PVector a, PVector b, PVector c, double ew) \{
        double t = ((c.x-a.x)*(b.x-a.x)+(c.y-a.y)*(b.y-a.y))
            / (pow(b.x-a.x, 2)+pow(b.y-a.y, 2));
        // d - base of the perpendicular from c to line a-b
        PVector d = new PVector(a.x+t*(b.x-a.x), a.y+t*(b.y-a.y));
        double k = ew / c.dist(d);
        return Arrays.asList(
            new PVector(a.x+k*(c.x-d.x), a.y+k*(c.y-d.y)),
            new PVector(b.x+k*(c.x-d.x), b.y+k*(c.y-d.y)));
    \}
    
    /**
     * https://algorithmtutor.com/Computational-Geometry/Check-if-a-point-is-inside-a-polygon/
     * 
     * @param polygon
     * @param point
     * @return 
     */
    boolean isWithinPolygon(List<PVector> polygon, PVector point) \{
        List<Double> as = new ArrayList<>(polygon.size());
        List<Double> bs = new ArrayList<>(polygon.size());
        List<Double> cs = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            PVector p1 = polygon.get(i);
            PVector p2 = polygon.get((i+1)%polygon.size());
            double a = -(p2.y - p1.y);
            double b = p2.x - p1.x;
            double c = -(a*p1.x + b*p1.y);
            as.add(a);
            bs.add(b);
            cs.add(c);
        \}
        List<Double> ds = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            double d = as.get(i)*point.x + bs.get(i)*point.y + cs.get(i);
            ds.add(d);
        \}
        boolean t1 = ds.stream().allMatch(d -> d <= EDGE_THRESHOLD);
        boolean t2 = ds.stream().allMatch(d -> d >= -EDGE_THRESHOLD);
        return t1 || t2;
    \}
    
    /**
     * find new intersection points of moved edges
     * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
     */
    List<PVector> verticesFromEdges(List<List<PVector>> edges) \{
        List<PVector> vertices = new ArrayList<>(edges.size());
        for (int i=0; i<edges.size(); ++i) \{
            List<PVector> e1 = edges.get(i);
            List<PVector> e2 = edges.get((i+1) % edges.size());
            
            PVector v1 = e1.get(0), v2 = e1.get(1), v3 = e2.get(0), v4 = e2.get(1);
            double denominator = (v1.x-v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x-v4.x);
            double x = ((v1.x*v2.y-v1.y*v2.x)*(v3.x-v4.x)-(v1.x-v2.x)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            double y = ((v1.x*v2.y-v1.y*v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            vertices.add(new PVector(x, y));
        \}
        return vertices;
    \}
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            noStroke();
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(REPLACE);
        textSize(10);
        fill(255, 0, 0);
        for(int i=0; i<cells.size(); ++i) \{
            if(cells.get(i).valid()) \{
                text(cells.get(i).label + i, cells.get(i).centre.x, cells.get(i).centre.y);
            \}
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.fill(255);
            outEdges.noStroke();
            outEdges.beginShape();

            PShape borders = outEdges.createShape().beginShape()
                    .vertex(0, height).vertex(0, 0)
                    .vertex(width, 0).vertex(width, height);
            cells.stream().filter(Cell::valid).forEach(cell -> \{
                borders.beginContour();
                cell.vertices.forEach(v -> borders.vertex(v.x, v.y));
                borders.endContour();
            \});
            borders.endShape();
            outEdges.shape(borders);
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        String label = \"\";
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 19.311472026808715
    .draw-cells true
    .draw-centers true
    .just-colours false
  }
  @ ./send-1 core:routing:send {
    #%graph.x 387
    #%graph.y 797
    .address /main-out/voronoi-renderer1.voronoi-in
  }
  @ ./grey video:gl:p2d {
    #%graph.x 387
    #%graph.y 519
    .code "

    @Override
    public void setup() \{
        fill(random(255));
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./grey1 video:gl:p2d {
    #%graph.x 382
    #%graph.y 595
    .code "

    @Override
    public void setup() \{
        fill(random(255));
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./grey3 video:gl:p2d {
    #%graph.x 409
    #%graph.y 685
    .code "

    @Override
    public void setup() \{
        fill(random(255));
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./looper1 core:timing:animator {
    #%graph.x 365
    #%graph.y 1007
    .code "

    @P(1) @Type.Number @ReadOnly
    Property value;
    @P(2) @Type.Number(def = 0)
    double time;
    
    @Out(1) Output out;
    
    @Override
    public void init() \{
        if(value.getInt() < 0.5) \{
            value.to(1).in(time).easeInOut().whenDone(p -> init());
        \} else \{
            value.to(0).in(time).easeInOut().whenDone(p -> init());
        \}
    \}
    
    @Override
    public void update() \{
        out.send(d(value)*20);
    \}
"
    .time 4
  }
  ~ ./voronoi-renderer1!out ./xfader-1!in-2
  ~ ./white!out ./voronoi-renderer1!in-0
  ~ ./xfader-1!out ./screen!in
  ~ ./voronoi-renderer!out ./voronoi-renderer1!in-edges
  ~ ./looper!out ./xfader-1!mix
  ~ ./grey!out ./voronoi-renderer1!in-1
  ~ ./grey1!out ./voronoi-renderer1!in-2
  ~ ./grey3!out ./voronoi-renderer1!in-3
  ~ ./voronoi-generator!voronoi-out ./send-1!in
  ~ ./looper1!out ./voronoi-renderer1!edge-width
  ~ ./voronoi-renderer!out ./xfader-1!in-1
  ~ ./voronoi-generator!voronoi-pipe-out ./voronoi-renderer!voronoi-pipe-in
  ~ ./strobe-timer!out ./voronoi-generator!move-cells
}
