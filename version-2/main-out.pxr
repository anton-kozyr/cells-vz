@ /main-out root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1051
    #%graph.y 268
    .device 2
    .always-on-top true
    .show-cursor true
  }
  @ ./strobe-timer core:timing:timer {
    #%graph.x -271
    #%graph.y 269
    .period 2.9843756906077346
  }
  @ ./voronoi-renderer video:gl:p2d {
    #%graph.x 550
    #%graph.y 68
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Initialisation

    @Override public void setup() \{
        initRefs();
        updateCellsInputs();
        Data.link(voronoiData, voronoiSink.input());
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();
            
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}

    void receiveCellGeometry() \{
        //TODO: validation
        //TODO: clone/update of cells list
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            this.edges = (double\[\]\[\]) v.get(\"edges\");
            List<PVector> centres = (List<PVector>) v.get(\"centres\");
            for(int i=0; i<centres.size(); ++i) \{
                cells.get(i).centre = centres.get(i);
            \}
            List<List<PVector>> vertices = (List<List<PVector>>) v.get(\"vertices\");
            for(int i=0; i<vertices.size(); ++i) \{
                cells.get(i).vertices = removeEdges(vertices.get(i));
            \}
        \}
    \}
    
    List<PVector> removeEdges(List<PVector> vertices) \{
//        for(int i=0; i<vertices.size()/2; ++i) \{
//            
//        \}
        return vertices;
    \}
    
    
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            if(cells.get(i).valid()) \{
                text(i, cells.get(i).centre.x, cells.get(i).centre.y);
            \}
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 1
    .draw-cells true
    .just-colours false
  }
  @ ./voronoi-sender video:gl:p2d {
    #%graph.x 171
    #%graph.y 92
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @AuxIn(100) Data.In<Map<String, double\[\]\[\]>> voronoiData;
    @Inject Data.Sink<Map<String, double\[\]\[\]>> voronoiSink;
    @Out(100) Data.Out<Map<String, double\[\]\[\]>> voronoiDataOut;
    @P(120) @Type.Boolean(def=false) boolean sender;   

    void receiveCellGeometry() \{
        Map<String, double\[\]\[\]> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\")) \{
            this.edges = v.get(\"edges\");
            this.vertices = v.get(\"vertices\");
        \}
    \}
    
    Map<String, double\[\]\[\]> sendCellGeometry() \{
        Map<String, double\[\]\[\]> v = new HashMap<>();
        v.put(\"edges\", edges);
        v.put(\"vertices\", vertices);
        double\[\]\[\] points = pointsRef.get().stream().map(p -> new double\[\] \{p.x, p.y\}).collect(Collectors.toList()).toArray(new double\[0\]\[\]);
        v.put(\"centres\", points);
        return v;
    \}  
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PointD>> pointsRef;
    
    // Coordinates of cell vertices
    double\[\]\[\] vertices;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    
    
    // Initialisation

    @Override public void setup() \{
        if(!sender) \{
            Data.link(voronoiData, voronoiSink.input());
        \} else \{
            Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
        \}
        initRefs();
        updateCellsInputs();
        updateCellsCount();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        pointsRef.init(CopyOnWriteArrayList::new);
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(
                    i,
                    ins\[inNo\], 
                    coloursRef.get().get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        pointsRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Arrays.asList(newPoints));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PointD point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        if(sender) \{
            updateCellsGeometry();
        \} else \{
            receiveCellGeometry();
        \}
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = pointsRef.get().get(i);
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                pointsRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved || vertices == null) \{
            recalculateVoronoiRegions();
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, cellsCount).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            double\[\] coords = vertices\[cell.no\];
            for(int i=0; i<coords.length/2; i+=1) \{
                double x = coords\[i*2\];
                double y = coords\[i*2+1\];
                vertex(x, y, x, y);
            \}
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<pointsRef.get().size(); ++i) \{
            PointD p = pointsRef.get().get(i);
            text(i, p.x, p.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}

    

    // Cell movement
    
    @T(1) public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        VoronoiResults results = Voronoi.findAll(pointsRef.get().toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        double\[\]\[\] newCoords = new double\[regions.length\]\[\];
        for(int i = 0; i<regions.length; ++i) \{
            newCoords\[i\] = PointD.toDoubles(regions\[i\]);
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        vertices = newCoords;
        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, PImage in, PVector colour, Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
"
    .movements All
    .time-to-move 0.8
    .cells-count 13
    .edge-width 8
    .draw-cells true
    .sender true
  }
  @ ./data-send core:custom {
    #%graph.x -188
    #%graph.y 17
    .code "

    @Out(1) Data.Out<Map<String, Object>> out;
    
    @P(1) double x;
    @P(2) double y;
    
    @Override
    public void init() \{
        Data.link(Data.supply(this::dataGen), out);
    \}

    Map<String, Object> dataGen() \{
        Map<String, Object> m = new HashMap<>();
        m.put(\"Dot\", new double\[\]\{x, y\});
        return m;
    \}
    
    @Override
    public void update() \{
        
    \}
"
    .x 16
    .y 300
  }
  @ ./data-receive video:gl:p2d {
    #%graph.x 25
    #%graph.y 17
    .code "

    @AuxIn(1) Data.In<Map<String, Object>> dataIn;

    @Inject Data.Sink<Map<String, Object>> sink;
    
    Map<String, double\[\]> data = null;

    @Override
    public void setup() \{
        Data.link(dataIn, sink.input());
    \}

    @Override
    public void draw() \{
        Map<String, Object> data = sink.process(Collections.emptyMap());
        if (data == null || data.isEmpty()) \{
            fill(100);
            rect(0, 0, width, height);
        \} else \{
            fill(255);
            double\[\] dot = (double\[\]) data.get(\"Dot\");
            ellipse(dot\[0\], dot\[1\], 10, 10);
        \}
    \}
"
  }
  @ ./xfader-1 video:xfader {
    #%graph.x 877
    #%graph.y 218
    .mix 0.9940828402366864
  }
  @ ./white video:gl:p2d {
    #%graph.x 388
    #%graph.y 152
    .code "

    @Override
    public void setup() \{
        fill(255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./looper core:timing:animator {
    #%graph.x 828
    #%graph.y 437
    .code "

    @P(1) @Type.Number @ReadOnly
    Property value;
    @P(2) @Type.Number(def = 0)
    double time;
    
    @Out(1) Output out;
    
    @Override
    public void init() \{
        if(value.getInt() < 0.5) \{
            value.to(1).in(time).whenDone(p -> init());
        \} else \{
            value.to(0).in(time).whenDone(p -> init());
        \}
    \}
    
    @Override
    public void update() \{
        out.send(d(value));
    \}
"
    .time 3
  }
  @ ./voronoi-renderer1 video:gl:p2d {
    #%graph.x 629
    #%graph.y 320
    .code "import org.locationtech.jts.geom.*;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    GeometryFactory geometryFactory = new GeometryFactory();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();

        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
        drawEdges();
    \}

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            Object centresObject = v.get(\"centres\");
            Object verticesObject = v.get(\"vertices\");
            if(centresObject instanceof List && verticesObject instanceof List) \{
                List<Cell> newCells = new ArrayList<>(cells);
                List<PVector> centres = (List<PVector>) centresObject;
                for(int i=0; i<centres.size(); ++i) \{
                    newCells.get(i).centre = centres.get(i);
                \}
                List<List<PVector>> vertices = (List<List<PVector>>) verticesObject;
                for(int i=0; i<vertices.size(); ++i) \{
                    updateEdges_custom(newCells.get(i), vertices.get(i));
                \}
                cells = newCells;
            \} else \{
                log(ERROR, \"Weird data received\");
            \}
        \}
    \}
    
    void updateEdges(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices || vertices.isEmpty()) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        final List<PVector> originalVertices = new ArrayList<>(vertices);
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        cell.vertices = Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}
    
    /**
     * Calculates inner polygons (removing edges)
     */
    void updateEdges_custom(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        int count = vertices.size();
        
        // push edges inside
        List<List<PVector>> edges = new ArrayList<>(count);
        for (int i=0; i<vertices.size(); ++i) \{
            PVector a = vertices.get(i);
            PVector b = vertices.get((i+1) % count);
            boolean verticalBorder = a.x == b.x && a.x % width < EDGE_THRESHOLD;
            boolean horisontalBorder = a.y == b.y && a.y % height < EDGE_THRESHOLD;
            if(verticalBorder || horisontalBorder) \{
                edges.add(Arrays.asList(a, b));
            \} else \{
                edges.add(moveEdge(a, b, cell.centre, edgeWidth/2)); 
            \}
        \}

        
        List<PVector> newVertices = verticesFromEdges(edges);
        
        cell.label = \"\" + count + \"\\n\";
        List<List<PVector>> cleanEdges = new ArrayList<>(count);
        // Clear self-intersection if found https://stackoverflow.com/a/7785719
        boolean previousBad = false;
        for (int i=-1; i<count; ++i) \{
            PVector na = newVertices.get((i+count-1) % count);
            PVector nb = newVertices.get((i+count) % count);
            PVector nc = newVertices.get((i+1) % count);
            PVector nba = na.copy().sub(nb);
            PVector nbc = nc.copy().sub(nb); 
            PVector nCross = nbc.copy().cross(nba);

            PVector oa = vertices.get((i+count-1) % count);
            PVector ob = vertices.get((i+count) % count);
            PVector oc = vertices.get((i+1) % count);
            PVector oba = oa.copy().sub(ob);
            PVector obc = oc.copy().sub(ob);
            PVector oCross = obc.copy().cross(oba);

            boolean bad = Math.signum(nCross.z) != Math.signum(oCross.z);
            if (i != -1) \{
                if(bad && !previousBad) \{
                    //cell.label += String.format(\"%.1f\\n\", nCross.z);
                    cell.label += \"-\\n\";
                    previousBad = true;
                \} else \{
                    cleanEdges.add(Arrays.asList(nb, nc));
                    cell.label += \"+\\n\";
                    previousBad = false;
                \}
            \} else \{
                previousBad = bad;
            \}

        \}
        newVertices = verticesFromEdges(cleanEdges);
        
        cell.vertices = newVertices.size() > 2 ? newVertices : Collections.emptyList();
    \}
    
    /**
     * Move edge towards centre https://stackoverflow.com/a/15187473
     * 
     * @param a first edge point
     * @param b second edge point
     * @param c centre
     * @param ew distance (edge half width)
     * @return two new points
     */
    List<PVector> moveEdge(PVector a, PVector b, PVector c, double ew) \{
        double t = ((c.x-a.x)*(b.x-a.x)+(c.y-a.y)*(b.y-a.y))
            / (pow(b.x-a.x, 2)+pow(b.y-a.y, 2));
        // d - base of the perpendicular from c to line a-b
        PVector d = new PVector(a.x+t*(b.x-a.x), a.y+t*(b.y-a.y));
        double k = ew / c.dist(d);
        return Arrays.asList(
            new PVector(a.x+k*(c.x-d.x), a.y+k*(c.y-d.y)),
            new PVector(b.x+k*(c.x-d.x), b.y+k*(c.y-d.y)));
    \}
    
    /**
     * https://algorithmtutor.com/Computational-Geometry/Check-if-a-point-is-inside-a-polygon/
     * 
     * @param polygon
     * @param point
     * @return 
     */
    boolean isWithinPolygon(List<PVector> polygon, PVector point) \{
        List<Double> as = new ArrayList<>(polygon.size());
        List<Double> bs = new ArrayList<>(polygon.size());
        List<Double> cs = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            PVector p1 = polygon.get(i);
            PVector p2 = polygon.get((i+1)%polygon.size());
            double a = -(p2.y - p1.y);
            double b = p2.x - p1.x;
            double c = -(a*p1.x + b*p1.y);
            as.add(a);
            bs.add(b);
            cs.add(c);
        \}
        List<Double> ds = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            double d = as.get(i)*point.x + bs.get(i)*point.y + cs.get(i);
            ds.add(d);
        \}
        boolean t1 = ds.stream().allMatch(d -> d <= EDGE_THRESHOLD);
        boolean t2 = ds.stream().allMatch(d -> d >= -EDGE_THRESHOLD);
        return t1 || t2;
    \}
    
    /**
     * find new intersection points of moved edges
     * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
     */
    List<PVector> verticesFromEdges(List<List<PVector>> edges) \{
        List<PVector> vertices = new ArrayList<>(edges.size());
        for (int i=0; i<edges.size(); ++i) \{
            List<PVector> e1 = edges.get(i);
            List<PVector> e2 = edges.get((i+1) % edges.size());
            
            PVector v1 = e1.get(0), v2 = e1.get(1), v3 = e2.get(0), v4 = e2.get(1);
            double denominator = (v1.x-v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x-v4.x);
            double x = ((v1.x*v2.y-v1.y*v2.x)*(v3.x-v4.x)-(v1.x-v2.x)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            double y = ((v1.x*v2.y-v1.y*v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            vertices.add(new PVector(x, y));
        \}
        return vertices;
    \}
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            noStroke();
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(REPLACE);
        textSize(10);
        fill(255, 0, 0);
        for(int i=0; i<cells.size(); ++i) \{
            if(cells.get(i).valid()) \{
                text(cells.get(i).label + i, cells.get(i).centre.x, cells.get(i).centre.y);
            \}
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.fill(255);
            outEdges.noStroke();
            outEdges.beginShape();

            PShape borders = outEdges.createShape().beginShape()
                    .vertex(0, height).vertex(0, 0)
                    .vertex(width, 0).vertex(width, height);
            cells.stream().filter(Cell::valid).forEach(cell -> \{
                borders.beginContour();
                cell.vertices.forEach(v -> borders.vertex(v.x, v.y));
                borders.endContour();
            \});
            borders.endShape();
            outEdges.shape(borders);
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        String label = \"\";
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 19.311472026808715
    .draw-cells true
    .draw-centers true
    .just-colours false
  }
  @ ./voronoi-generator core:custom {
    #%graph.x -100
    #%graph.y 382
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @Out(100) Data.Out<Map<String, Object>> voronoiDataOut;
    @P(120) @Type.Boolean(def=false) boolean sender;   
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    @P(100) @Type.Integer(def=800) @OnChange(\"init\") int width;
    @P(101) @Type.Integer(def=600) @OnChange(\"init\") int height;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
    \}

    Map<String, Object> sendCellGeometry() \{
        Map<String, Object> v = new HashMap<>();
        v.put(\"edges\", edges);
        List<List<PVector>> vertices = cells.subList(0, cellsCount).stream()
                .map(Cell::vertices).collect(Collectors.toList());
        v.put(\"vertices\", vertices);
        v.put(\"centres\", centresRef.get().subList(0, cellsCount));
        return v;
    \}  
    
    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            Cell cell = new Cell(
                    i,
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();
        \}
    \}

    // Cell movement
    
    @T(1)
    public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(-1000, -1000, width+1000, height+1000);
        List<PointD> centers = centresRef.get().stream().map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).vertices = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final Property moveX;
        final Property moveY;
        List<PVector> vertices;
        
        Cell(int no, Property moveX, Property moveY) \{
            this.no = no;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        List<PVector> vertices() \{
            return vertices;
        \}
    \}
"
    .movements All
    .cells-count 10
  }
  @ ./blue video:gl:p2d {
    #%graph.x 409
    #%graph.y 387
    .code "

    @Override
    public void setup() \{
        fill(0, 0, 255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./voronoi-attempt-to-shrink-manually video:gl:p2d {
    #%graph.x 921
    #%graph.y 597
    .code "import org.locationtech.jts.geom.*;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    GeometryFactory geometryFactory = new GeometryFactory();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();

        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
        drawEdges();
    \}

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            Object centresObject = v.get(\"centres\");
            Object verticesObject = v.get(\"vertices\");
            if(centresObject instanceof List && verticesObject instanceof List) \{
                List<Cell> newCells = new ArrayList<>(cells);
                List<PVector> centres = (List<PVector>) centresObject;
                for(int i=0; i<centres.size(); ++i) \{
                    newCells.get(i).centre = centres.get(i);
                \}
                List<List<PVector>> vertices = (List<List<PVector>>) verticesObject;
                for(int i=0; i<vertices.size(); ++i) \{
                    updateEdges_custom(newCells.get(i), vertices.get(i));
                \}
                cells = newCells;
            \} else \{
                log(ERROR, \"Weird data received\");
            \}
        \}
    \}
    
    void updateEdges(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices || vertices.isEmpty()) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        final List<PVector> originalVertices = new ArrayList<>(vertices);
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        cell.vertices = Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}
    
    /**
     * Calculates inner polygons (removing edges)
     */
    void updateEdges_custom(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        int count = vertices.size();
        
        // push edges inside
        List<List<PVector>> edges = new ArrayList<>(count);
        for (int i=0; i<vertices.size(); ++i) \{
            PVector a = vertices.get(i);
            PVector b = vertices.get((i+1) % count);
            boolean verticalBorder = a.x == b.x && a.x % width < EDGE_THRESHOLD;
            boolean horisontalBorder = a.y == b.y && a.y % height < EDGE_THRESHOLD;
            if(verticalBorder || horisontalBorder) \{
                edges.add(Arrays.asList(a, b));
            \} else \{
                edges.add(moveEdge(a, b, cell.centre, edgeWidth/2)); 
            \}
        \}

        
        List<PVector> newVertices = verticesFromEdges(edges);
        
        cell.label = \"\" + count + \"\\n\";
        List<List<PVector>> cleanEdges = new ArrayList<>(count);
        // Clear self-intersection if found https://stackoverflow.com/a/7785719
        boolean previousBad = false;
        for (int i=-1; i<count; ++i) \{
            PVector na = newVertices.get((i+count-1) % count);
            PVector nb = newVertices.get((i+count) % count);
            PVector nc = newVertices.get((i+1) % count);
            PVector nba = na.copy().sub(nb);
            PVector nbc = nc.copy().sub(nb); 
            PVector nCross = nbc.copy().cross(nba);

            PVector oa = vertices.get((i+count-1) % count);
            PVector ob = vertices.get((i+count) % count);
            PVector oc = vertices.get((i+1) % count);
            PVector oba = oa.copy().sub(ob);
            PVector obc = oc.copy().sub(ob);
            PVector oCross = obc.copy().cross(oba);

            boolean bad = Math.signum(nCross.z) != Math.signum(oCross.z);
            if (i != -1) \{
                if(bad && !previousBad) \{
                    //cell.label += String.format(\"%.1f\\n\", nCross.z);
                    cell.label += \"-\\n\";
                    previousBad = true;
                \} else \{
                    cleanEdges.add(Arrays.asList(nb, nc));
                    cell.label += \"+\\n\";
                    previousBad = false;
                \}
            \} else \{
                previousBad = bad;
            \}

        \}
        newVertices = verticesFromEdges(cleanEdges);
        
        cell.vertices = newVertices.size() > 2 ? newVertices : Collections.emptyList();
    \}
    
    /**
     * Move edge towards centre https://stackoverflow.com/a/15187473
     * 
     * @param a first edge point
     * @param b second edge point
     * @param c centre
     * @param ew distance (edge half width)
     * @return two new points
     */
    List<PVector> moveEdge(PVector a, PVector b, PVector c, double ew) \{
        double t = ((c.x-a.x)*(b.x-a.x)+(c.y-a.y)*(b.y-a.y))
            / (pow(b.x-a.x, 2)+pow(b.y-a.y, 2));
        // d - base of the perpendicular from c to line a-b
        PVector d = new PVector(a.x+t*(b.x-a.x), a.y+t*(b.y-a.y));
        double k = ew / c.dist(d);
        return Arrays.asList(
            new PVector(a.x+k*(c.x-d.x), a.y+k*(c.y-d.y)),
            new PVector(b.x+k*(c.x-d.x), b.y+k*(c.y-d.y)));
    \}
    
    /**
     * https://algorithmtutor.com/Computational-Geometry/Check-if-a-point-is-inside-a-polygon/
     * 
     * @param polygon
     * @param point
     * @return 
     */
    boolean isWithinPolygon(List<PVector> polygon, PVector point) \{
        List<Double> as = new ArrayList<>(polygon.size());
        List<Double> bs = new ArrayList<>(polygon.size());
        List<Double> cs = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            PVector p1 = polygon.get(i);
            PVector p2 = polygon.get((i+1)%polygon.size());
            double a = -(p2.y - p1.y);
            double b = p2.x - p1.x;
            double c = -(a*p1.x + b*p1.y);
            as.add(a);
            bs.add(b);
            cs.add(c);
        \}
        List<Double> ds = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            double d = as.get(i)*point.x + bs.get(i)*point.y + cs.get(i);
            ds.add(d);
        \}
        boolean t1 = ds.stream().allMatch(d -> d <= EDGE_THRESHOLD);
        boolean t2 = ds.stream().allMatch(d -> d >= -EDGE_THRESHOLD);
        return t1 || t2;
    \}
    
    /**
     * find new intersection points of moved edges
     * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
     */
    List<PVector> verticesFromEdges(List<List<PVector>> edges) \{
        List<PVector> vertices = new ArrayList<>(edges.size());
        for (int i=0; i<edges.size(); ++i) \{
            List<PVector> e1 = edges.get(i);
            List<PVector> e2 = edges.get((i+1) % edges.size());
            
            PVector v1 = e1.get(0), v2 = e1.get(1), v3 = e2.get(0), v4 = e2.get(1);
            double denominator = (v1.x-v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x-v4.x);
            double x = ((v1.x*v2.y-v1.y*v2.x)*(v3.x-v4.x)-(v1.x-v2.x)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            double y = ((v1.x*v2.y-v1.y*v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            vertices.add(new PVector(x, y));
        \}
        return vertices;
    \}
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            noStroke();
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(REPLACE);
        textSize(10);
        fill(255, 0, 0);
        for(int i=0; i<cells.size(); ++i) \{
            if(cells.get(i).valid()) \{
                text(cells.get(i).label + i, cells.get(i).centre.x, cells.get(i).centre.y);
            \}
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.fill(255);
            outEdges.noStroke();
            outEdges.beginShape();

            PShape borders = outEdges.createShape().beginShape()
                    .vertex(0, height).vertex(0, 0)
                    .vertex(width, 0).vertex(width, height);
            cells.stream().filter(Cell::valid).forEach(cell -> \{
                borders.beginContour();
                cell.vertices.forEach(v -> borders.vertex(v.x, v.y));
                borders.endContour();
            \});
            borders.endShape();
            outEdges.shape(borders);
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        String label = \"\";
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 19.311472026808715
    .draw-cells true
    .draw-centers true
    .just-colours false
  }
  ~ ./xfader-1!out ./screen!in
  ~ ./strobe-timer!out ./voronoi-sender!move-cells
  ~ ./voronoi-renderer1!out ./xfader-1!in-2
  ~ ./data-receive!out ./screen!in
  ~ ./data-send!out ./data-receive!data-in
  ~ ./voronoi-generator!voronoi-data-out ./voronoi-renderer1!voronoi-data
  ~ ./voronoi-renderer!out ./xfader-1!in-1
  ~ ./white!out ./voronoi-renderer!in-0
  ~ ./white!out ./voronoi-renderer!in-edges
  ~ ./strobe-timer!out ./voronoi-generator!move-cells
  ~ ./white!out ./voronoi-renderer1!in-0
  ~ ./white!out ./voronoi-renderer1!in-edges
  ~ ./blue!out ./voronoi-renderer1!in-edges
}
