@ /main-out root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1051
    #%graph.y 268
    .always-on-top true
    .show-cursor true
  }
  @ ./strobe-timer core:timing:timer {
    #%graph.x -271
    #%graph.y 269
    .period 2.9843756906077346
  }
  @ ./voronoi-renderer video:gl:p2d {
    #%graph.x 557
    #%graph.y 64
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Coordinates of cell centres
    double\[\]\[\] centres;
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();
            
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}

    void receiveCellGeometry() \{
        //TODO: validation
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            this.edges = (double\[\]\[\]) v.get(\"edges\");
            List<List<PVector>> vertices = (List<List<PVector>>) v.get(\"vertices\");
            for(int i=0; i<vertices.size(); ++i) \{
                cells.get(i).vertices = vertices.get(i);
            \}
            this.centres = (double\[\]\[\]) v.get(\"centres\");
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, centres.length).stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            cell.vertices.forEach(v -> vertex(v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<centres.length; ++i) \{
            text(i, centres\[i\]\[0\], centres\[i\]\[1\]);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        List<PVector> vertices;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 8
    .draw-cells true
    .just-colours false
  }
  @ ./voronoi-sender video:gl:p2d {
    #%graph.x 171
    #%graph.y 92
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @AuxIn(100) Data.In<Map<String, double\[\]\[\]>> voronoiData;
    @Inject Data.Sink<Map<String, double\[\]\[\]>> voronoiSink;
    @Out(100) Data.Out<Map<String, double\[\]\[\]>> voronoiDataOut;
    @P(120) @Type.Boolean(def=false) boolean sender;   

    void receiveCellGeometry() \{
        Map<String, double\[\]\[\]> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\")) \{
            this.edges = v.get(\"edges\");
            this.vertices = v.get(\"vertices\");
        \}
    \}
    
    Map<String, double\[\]\[\]> sendCellGeometry() \{
        Map<String, double\[\]\[\]> v = new HashMap<>();
        v.put(\"edges\", edges);
        v.put(\"vertices\", vertices);
        double\[\]\[\] points = pointsRef.get().stream().map(p -> new double\[\] \{p.x, p.y\}).collect(Collectors.toList()).toArray(new double\[0\]\[\]);
        v.put(\"centres\", points);
        return v;
    \}  
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PointD>> pointsRef;
    
    // Coordinates of cell vertices
    double\[\]\[\] vertices;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    
    
    // Initialisation

    @Override public void setup() \{
        if(!sender) \{
            Data.link(voronoiData, voronoiSink.input());
        \} else \{
            Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
        \}
        initRefs();
        updateCellsInputs();
        updateCellsCount();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        pointsRef.init(CopyOnWriteArrayList::new);
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(
                    i,
                    ins\[inNo\], 
                    coloursRef.get().get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        pointsRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Arrays.asList(newPoints));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PointD point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        if(sender) \{
            updateCellsGeometry();
        \} else \{
            receiveCellGeometry();
        \}
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = pointsRef.get().get(i);
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                pointsRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved || vertices == null) \{
            recalculateVoronoiRegions();
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, cellsCount).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            double\[\] coords = vertices\[cell.no\];
            for(int i=0; i<coords.length/2; i+=1) \{
                double x = coords\[i*2\];
                double y = coords\[i*2+1\];
                vertex(x, y, x, y);
            \}
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<pointsRef.get().size(); ++i) \{
            PointD p = pointsRef.get().get(i);
            text(i, p.x, p.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}

    

    // Cell movement
    
    @T(1) public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        VoronoiResults results = Voronoi.findAll(pointsRef.get().toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        double\[\]\[\] newCoords = new double\[regions.length\]\[\];
        for(int i = 0; i<regions.length; ++i) \{
            newCoords\[i\] = PointD.toDoubles(regions\[i\]);
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        vertices = newCoords;
        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, PImage in, PVector colour, Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
"
    .movements All
    .time-to-move 0.8
    .cells-count 13
    .edge-width 8
    .draw-cells true
    .sender true
  }
  @ ./data-send core:custom {
    #%graph.x -188
    #%graph.y 17
    .code "

    @Out(1) Data.Out<Map<String, Object>> out;
    
    @P(1) double x;
    @P(2) double y;
    
    @Override
    public void init() \{
        Data.link(Data.supply(this::dataGen), out);
    \}

    Map<String, Object> dataGen() \{
        Map<String, Object> m = new HashMap<>();
        m.put(\"Dot\", new double\[\]\{x, y\});
        return m;
    \}
    
    @Override
    public void update() \{
        
    \}
"
    .x 16
    .y 300
  }
  @ ./data-receive video:gl:p2d {
    #%graph.x 25
    #%graph.y 17
    .code "

    @AuxIn(1) Data.In<Map<String, Object>> dataIn;

    @Inject Data.Sink<Map<String, Object>> sink;
    
    Map<String, double\[\]> data = null;

    @Override
    public void setup() \{
        Data.link(dataIn, sink.input());
    \}

    @Override
    public void draw() \{
        Map<String, Object> data = sink.process(Collections.emptyMap());
        if (data == null || data.isEmpty()) \{
            fill(100);
            rect(0, 0, width, height);
        \} else \{
            fill(255);
            double\[\] dot = (double\[\]) data.get(\"Dot\");
            ellipse(dot\[0\], dot\[1\], 10, 10);
        \}
    \}
"
  }
  @ ./xfader-1 video:xfader {
    #%graph.x 878
    #%graph.y 218
    .mix 0.1308030071755567
  }
  @ ./white video:gl:p2d {
    #%graph.x 388
    #%graph.y 152
    .code "

    @Override
    public void setup() \{
        fill(255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./looper core:timing:animator {
    #%graph.x 828
    #%graph.y 437
    .code "

    @P(1) @Type.Number @ReadOnly
    Property value;
    @P(2) @Type.Number(def = 0)
    double time;
    
    @Out(1) Output out;
    
    @Override
    public void init() \{
        if(value.getInt() < 0.5) \{
            value.to(1).in(time).whenDone(p -> init());
        \} else \{
            value.to(0).in(time).whenDone(p -> init());
        \}
    \}
    
    @Override
    public void update() \{
        out.send(d(value));
    \}
"
    .time 3
  }
  @ ./voronoi-renderer1 video:gl:p2d {
    #%graph.x 629
    #%graph.y 320
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();
            
        if(drawCells) \{
            drawCells();
        \}
//        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}

    void receiveCellGeometry() \{
        //TODO: validation
        //TODO: clone/update of cells list
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            this.edges = (double\[\]\[\]) v.get(\"edges\");
            List<PVector> centres = (List<PVector>) v.get(\"centres\");
            for(int i=0; i<centres.size(); ++i) \{
                cells.get(i).centre = centres.get(i);
            \}
            List<List<PVector>> vertices = (List<List<PVector>>) v.get(\"vertices\");
            for(int i=0; i<vertices.size(); ++i) \{
                cells.get(i).vertices = removeEdges(vertices.get(i));
            \}
        \}
    \}
    
    List<PVector> removeEdges(List<PVector> vertices) \{
//        for(int i=0; i<vertices.size()/2; ++i) \{
//            
//        \}
        return vertices;
    \}
    
    
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            noStroke();
            cell.vertices.forEach(v -> vertex(v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .edge-width 5.842459980124761
    .draw-cells true
    .draw-centers true
  }
  @ ./voronoi-generator core:custom {
    #%graph.x -100
    #%graph.y 382
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @Out(100) Data.Out<Map<String, Object>> voronoiDataOut;
    @P(120) @Type.Boolean(def=false) boolean sender;   
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    @P(100) @Type.Integer(def=800) @OnChange(\"init\") int width;
    @P(101) @Type.Integer(def=600) @OnChange(\"init\") int height;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
    \}

    Map<String, Object> sendCellGeometry() \{
        Map<String, Object> v = new HashMap<>();
        v.put(\"edges\", edges);
        List<List<PVector>> vertices = cells.stream().map(Cell::vertices).collect(Collectors.toList());
        v.put(\"vertices\", vertices);
        v.put(\"centres\", centresRef.get());
        return v;
    \}  
    
    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            Cell cell = new Cell(
                    i,
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();
        \}
    \}

    // Cell movement
    
    @T(1)
    public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0, 0, width , height);
        List<PointD> centers = centresRef.get().stream().map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).vertices = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final Property moveX;
        final Property moveY;
        List<PVector> vertices;
        
        Cell(int no, Property moveX, Property moveY) \{
            this.no = no;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        List<PVector> vertices() \{
            return vertices;
        \}
    \}
"
    .cells-count 10
  }
  ~ ./white!out ./voronoi-renderer!in-edges
  ~ ./white!out ./voronoi-renderer!in-1
  ~ ./xfader-1!out ./screen!in
  ~ ./looper!out ./xfader-1!mix
  ~ ./strobe-timer!out ./voronoi-sender!move-cells
  ~ ./strobe-timer!out ./voronoi-generator!move-cells
  ~ ./voronoi-renderer1!out ./xfader-1!in-2
  ~ ./data-receive!out ./screen!in
  ~ ./data-send!out ./data-receive!data-in
  ~ ./voronoi-generator!voronoi-data-out ./voronoi-renderer1!voronoi-data
}
