@ /main-out root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1051
    #%graph.y 268
    .device 2
    .always-on-top true
    .show-cursor true
  }
  @ ./strobe-timer core:timing:timer {
    #%graph.x -271
    #%graph.y 269
    .period 2.9843756906077346
  }
  @ ./voronoi-renderer video:gl:p2d {
    #%graph.x 639
    #%graph.y 1
    .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;

    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    GeometryFactory geometryFactory = new GeometryFactory();
    
    @P(200) @OnChange(\"receive\") PBytes voronoiFarData;
    
    @P(300) @Transient @ReadOnly String receivingSource;
        
    void receive() \{
        DataInputStream dis = new DataInputStream(voronoiFarData.asInputStream());
        try \{
            int cellsCount = dis.readInt();
            List<PVector> centres = new ArrayList<>();
            List<List<PVector>> polygons = new ArrayList<>();
            for (int i=0; i<cellsCount; ++i) \{
                centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                int verticesCount = dis.readInt();
                List<PVector> polygon = new ArrayList<>();
                for (int j=0; j<verticesCount; ++j) \{
                    polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                \}
                polygons.add(polygon);
            \}
            dis.close();
            
            cells = geometryToCells(centres, polygons);
        \} catch (IOException ex) \{
            log(ERROR, \"WTF\");
        \}
    \};
    
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Receive and parse voronoi data

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if((v.isEmpty() || !v.containsKey(\"vertices\")) || !v.containsKey(\"centres\")) \{
            receivingSource = \"No voronoi data received through the pipe\";
//            log(ERROR, \"No voronoi data received\");
            return;
        \}
        receivingSource = \"Received data through the pipe\"; // TODO: add check for double receiving
        Object centresObject = v.get(\"centres\");
        Object verticesObject = v.get(\"vertices\");
        if(!(centresObject instanceof List) || !(verticesObject instanceof List)) \{
            log(ERROR, \"Wrongly typed voronoi data received\");
            return;
        \}
        List<PVector> centres = (List<PVector>) centresObject;
        List<List<PVector>> polygons = (List<List<PVector>>) verticesObject;
        if(centres.size() != polygons.size()) \{
            log(ERROR, \"Mismatch centres and polygons count in voronoi data\");
            return;
        \}
        
        cells = geometryToCells(centres, polygons);
    \}
    
    List<Cell> geometryToCells(List<PVector> centres, List<List<PVector>> polygons) \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<centres.size(); ++i) \{
            List<PVector> vertices = polygons.get(i);
            if (null == vertices || vertices.isEmpty()) \{
                log(WARNING, \"Received weird cell \" + i);
            \} else \{
                cells.add(new Cell(i, centres.get(i), expandEdges(i, vertices)));
            \}
        \}
        return cells;
    \}
    
    List<PVector> expandEdges(int cellNo, List<PVector> vertices) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return vertices;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(vertices);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> vertices;

        public Cell(int no, PVector centre, List<PVector> vertices) \{
            this.no = no;
            this.centre = centre;
            this.vertices = vertices;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
"
    .cells-inputs 4
    .edge-width 1
    .draw-cells true
    .just-colours false
  }
  @ ./voronoi-sender video:gl:p2d {
    #%graph.x 171
    #%graph.y 92
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @AuxIn(100) Data.In<Map<String, double\[\]\[\]>> voronoiData;
    @Inject Data.Sink<Map<String, double\[\]\[\]>> voronoiSink;
    @Out(100) Data.Out<Map<String, double\[\]\[\]>> voronoiDataOut;
    @P(120) @Type.Boolean(def=false) boolean sender;   

    void receiveCellGeometry() \{
        Map<String, double\[\]\[\]> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"edges\") && v.containsKey(\"vertices\")) \{
            this.edges = v.get(\"edges\");
            this.vertices = v.get(\"vertices\");
        \}
    \}
    
    Map<String, double\[\]\[\]> sendCellGeometry() \{
        Map<String, double\[\]\[\]> v = new HashMap<>();
        v.put(\"edges\", edges);
        v.put(\"vertices\", vertices);
        double\[\]\[\] points = pointsRef.get().stream().map(p -> new double\[\] \{p.x, p.y\}).collect(Collectors.toList()).toArray(new double\[0\]\[\]);
        v.put(\"centres\", points);
        return v;
    \}  
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PointD>> pointsRef;
    
    // Coordinates of cell vertices
    double\[\]\[\] vertices;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    
    
    // Initialisation

    @Override public void setup() \{
        if(!sender) \{
            Data.link(voronoiData, voronoiSink.input());
        \} else \{
            Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
        \}
        initRefs();
        updateCellsInputs();
        updateCellsCount();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        pointsRef.init(CopyOnWriteArrayList::new);
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(
                    i,
                    ins\[inNo\], 
                    coloursRef.get().get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        pointsRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Arrays.asList(newPoints));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PointD point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        if(sender) \{
            updateCellsGeometry();
        \} else \{
            receiveCellGeometry();
        \}
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = pointsRef.get().get(i);
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                pointsRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved || vertices == null) \{
            recalculateVoronoiRegions();
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, cellsCount).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            double\[\] coords = vertices\[cell.no\];
            for(int i=0; i<coords.length/2; i+=1) \{
                double x = coords\[i*2\];
                double y = coords\[i*2+1\];
                vertex(x, y, x, y);
            \}
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<pointsRef.get().size(); ++i) \{
            PointD p = pointsRef.get().get(i);
            text(i, p.x, p.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}

    

    // Cell movement
    
    @T(1) public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        VoronoiResults results = Voronoi.findAll(pointsRef.get().toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        double\[\]\[\] newCoords = new double\[regions.length\]\[\];
        for(int i = 0; i<regions.length; ++i) \{
            newCoords\[i\] = PointD.toDoubles(regions\[i\]);
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        vertices = newCoords;
        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, PImage in, PVector colour, Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
"
    .movements All
    .time-to-move 0.8
    .cells-count 13
    .edge-width 8
    .draw-cells true
    .sender true
  }
  @ ./data-send core:custom {
    #%graph.x -188
    #%graph.y 17
    .code "

    @Out(1) Data.Out<Map<String, Object>> out;
    
    @P(1) double x;
    @P(2) double y;
    
    @Override
    public void init() \{
        Data.link(Data.supply(this::dataGen), out);
    \}

    Map<String, Object> dataGen() \{
        Map<String, Object> m = new HashMap<>();
        m.put(\"Dot\", new double\[\]\{x, y\});
        return m;
    \}
    
    @Override
    public void update() \{
        
    \}
"
    .x 16
    .y 300
  }
  @ ./data-receive video:gl:p2d {
    #%graph.x 25
    #%graph.y 17
    .code "

    @AuxIn(1) Data.In<Map<String, Object>> dataIn;

    @Inject Data.Sink<Map<String, Object>> sink;
    
    Map<String, double\[\]> data = null;

    @Override
    public void setup() \{
        Data.link(dataIn, sink.input());
    \}

    @Override
    public void draw() \{
        Map<String, Object> data = sink.process(Collections.emptyMap());
        if (data == null || data.isEmpty()) \{
            fill(100);
            rect(0, 0, width, height);
        \} else \{
            fill(255);
            double\[\] dot = (double\[\]) data.get(\"Dot\");
            ellipse(dot\[0\], dot\[1\], 10, 10);
        \}
    \}
"
  }
  @ ./xfader-1 video:xfader {
    #%graph.x 877
    #%graph.y 218
    .mix 0.6627218934911243
  }
  @ ./white video:gl:p2d {
    #%graph.x 388
    #%graph.y 152
    .code "

    @Override
    public void setup() \{
        fill(255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./looper core:timing:animator {
    #%graph.x 828
    #%graph.y 437
    .code "

    @P(1) @Type.Number @ReadOnly
    Property value;
    @P(2) @Type.Number(def = 0)
    double time;
    
    @Out(1) Output out;
    
    @Override
    public void init() \{
        if(value.getInt() < 0.5) \{
            value.to(1).in(time).whenDone(p -> init());
        \} else \{
            value.to(0).in(time).whenDone(p -> init());
        \}
    \}
    
    @Override
    public void update() \{
        out.send(d(value));
    \}
"
    .time 3
  }
  @ ./voronoi-renderer1 video:gl:p2d {
    #%graph.x 668
    #%graph.y 485
    .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;

    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    GeometryFactory geometryFactory = new GeometryFactory();
    
    @P(200) @OnChange(\"receive\") PBytes voronoiFarData;
    
    @P(300) @Transient @ReadOnly String receivingSource;
        
    void receive() \{
        DataInputStream dis = new DataInputStream(voronoiFarData.asInputStream());
        try \{
            int cellsCount = dis.readInt();
            List<PVector> centres = new ArrayList<>();
            List<List<PVector>> polygons = new ArrayList<>();
            for (int i=0; i<cellsCount; ++i) \{
                centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                int verticesCount = dis.readInt();
                List<PVector> polygon = new ArrayList<>();
                for (int j=0; j<verticesCount; ++j) \{
                    polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                \}
                polygons.add(polygon);
            \}
            dis.close();
            
            cells = geometryToCells(centres, polygons);
        \} catch (IOException ex) \{
            log(ERROR, \"WTF\");
        \}
    \};
    
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Receive and parse voronoi data

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if((v.isEmpty() || !v.containsKey(\"vertices\")) || !v.containsKey(\"centres\")) \{
            receivingSource = \"No voronoi data received through the pipe\";
//            log(ERROR, \"No voronoi data received\");
            return;
        \}
        receivingSource = \"Received data through the pipe\"; // TODO: add check for double receiving
        Object centresObject = v.get(\"centres\");
        Object verticesObject = v.get(\"vertices\");
        if(!(centresObject instanceof List) || !(verticesObject instanceof List)) \{
            log(ERROR, \"Wrongly typed voronoi data received\");
            return;
        \}
        List<PVector> centres = (List<PVector>) centresObject;
        List<List<PVector>> polygons = (List<List<PVector>>) verticesObject;
        if(centres.size() != polygons.size()) \{
            log(ERROR, \"Mismatch centres and polygons count in voronoi data\");
            return;
        \}
        
        cells = geometryToCells(centres, polygons);
    \}
    
    List<Cell> geometryToCells(List<PVector> centres, List<List<PVector>> polygons) \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<centres.size(); ++i) \{
            List<PVector> vertices = polygons.get(i);
            if (null == vertices || vertices.isEmpty()) \{
                log(WARNING, \"Received weird cell \" + i);
            \} else \{
                cells.add(new Cell(i, centres.get(i), expandEdges(i, vertices)));
            \}
        \}
        return cells;
    \}
    
    List<PVector> expandEdges(int cellNo, List<PVector> vertices) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return vertices;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(vertices);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> vertices;

        public Cell(int no, PVector centre, List<PVector> vertices) \{
            this.no = no;
            this.centre = centre;
            this.vertices = vertices;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
"
    .cells-inputs 4
    .edge-width 20.56710084356379
    .draw-cells true
    .just-colours false
    .voronoi-far-data "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"
  }
  @ ./voronoi-generator core:custom {
    #%graph.x -100
    #%graph.y 382
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.io.DataOutputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 40;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;

    @P(11) @Type.Integer(def=800) @OnChange(\"init\") int width;
    @P(12) @Type.Integer(def=600) @OnChange(\"init\") int height;
    
    @Out(100) Data.Out<Map<String, Object>> voronoiDataOut;
    @Out(101) Output vorOut;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::sendCellGeometry), voronoiDataOut);
    \}

    Map<String, Object> sendCellGeometry() \{
        Map<String, Object> v = new HashMap<>();
        List<List<PVector>> vertices = cells.subList(0, cellsCount).stream()
                .map(Cell::vertices).collect(Collectors.toList());
        v.put(\"vertices\", vertices);
        v.put(\"centres\", centresRef.get().subList(0, cellsCount));
        return v;
    \}  
    
    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            Cell cell = new Cell(
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();

            //TODO: cleanup
            PBytes.OutputStream os = new PBytes.OutputStream();
            DataOutputStream dos = new DataOutputStream(os);
            try \{
                dos.writeInt(cellsCount);
                for(int i=0; i<cellsCount; ++i) \{
                    PVector centre = centresRef.get().get(i);
                    dos.writeDouble(centre.x);
                    dos.writeDouble(centre.y);
                    Cell cell = cells.get(i);
                    dos.writeInt(cell.vertices.size());
                    cell.vertices.forEach(v -> \{
                        try \{
                            dos.writeDouble(v.x);
                            dos.writeDouble(v.y);
                        \} catch (IOException ex) \{
                            log(ERROR, \"OOpsie2\"); //TODO: clean up this shit
                        \}
                    \});
                \}
                dos.flush();
                vorOut.send(os.toBytes());
                dos.close();
            \} catch (IOException ex) \{
                log(ERROR, \"OOpsie\");
            \}
        \}
    \}

    // Cell movement
    
    @T(1)
    public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(-1000, -1000, width+1000, height+1000);
        List<PointD> centers = centresRef.get().stream().map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).vertices = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
    \}



    // Cell container TODO: split this into mutable/immutable

    static class Cell \{
        final Property moveX;
        final Property moveY;
        List<PVector> vertices;
        
        Cell(Property moveX, Property moveY) \{
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        List<PVector> vertices() \{
            return vertices;
        \}
    \}
"
    .movements All
    .cells-count 32
  }
  @ ./blue video:gl:p2d {
    #%graph.x 409
    #%graph.y 387
    .code "

    @Override
    public void setup() \{
        fill(0, 0, 255);
    \}

    @Override
    public void draw() \{
        rect(0, 0, width, height);
    \}
"
  }
  @ ./voronoi-attempt-to-shrink-manually video:gl:p2d {
    #%graph.x 921
    #%graph.y 597
    .code "import org.locationtech.jts.geom.*;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;

    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";

    @AuxIn(100) Data.In<Map<String, Object>> voronoiData;
    @Inject Data.Sink<Map<String, Object>> voronoiSink;
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) @OnChange(\"updateEdges\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    GeometryFactory geometryFactory = new GeometryFactory();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiData, voronoiSink.input());
        
        initRefs();
        updateCellsInputs();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(i, ins\[inNo\], coloursRef.get().get(i));
            newCells.add(cell);
        \}
        cells = newCells;
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        receiveCellGeometry();

        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
        drawEdges();
    \}

    void receiveCellGeometry() \{
        Map<String,Object> v = voronoiSink.process(Collections.emptyMap());
        if(!v.isEmpty() && v.containsKey(\"vertices\") && v.containsKey(\"centres\")) \{
            Object centresObject = v.get(\"centres\");
            Object verticesObject = v.get(\"vertices\");
            if(centresObject instanceof List && verticesObject instanceof List) \{
                List<Cell> newCells = new ArrayList<>(cells);
                List<PVector> centres = (List<PVector>) centresObject;
                for(int i=0; i<centres.size(); ++i) \{
                    newCells.get(i).centre = centres.get(i);
                \}
                List<List<PVector>> vertices = (List<List<PVector>>) verticesObject;
                for(int i=0; i<vertices.size(); ++i) \{
                    updateEdges_custom(newCells.get(i), vertices.get(i));
                \}
                cells = newCells;
            \} else \{
                log(ERROR, \"Weird data received\");
            \}
        \}
    \}
    
    void updateEdges(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices || vertices.isEmpty()) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        final List<PVector> originalVertices = new ArrayList<>(vertices);
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon polygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = polygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        cell.vertices = Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}
    
    /**
     * Calculates inner polygons (removing edges)
     */
    void updateEdges_custom(Cell cell, List<PVector> vertices) \{
        // leave as is if no edge
        if (edgeWidth < EDGE_THRESHOLD) \{
            cell.vertices = vertices;
            return;
        \}
        if (null == vertices) \{
            log(WARNING, \"Received weird cell \" + cell.no);
            return;
        \}
        
        int count = vertices.size();
        
        // push edges inside
        List<List<PVector>> edges = new ArrayList<>(count);
        for (int i=0; i<vertices.size(); ++i) \{
            PVector a = vertices.get(i);
            PVector b = vertices.get((i+1) % count);
            boolean verticalBorder = a.x == b.x && a.x % width < EDGE_THRESHOLD;
            boolean horisontalBorder = a.y == b.y && a.y % height < EDGE_THRESHOLD;
            if(verticalBorder || horisontalBorder) \{
                edges.add(Arrays.asList(a, b));
            \} else \{
                edges.add(moveEdge(a, b, cell.centre, edgeWidth/2)); 
            \}
        \}

        
        List<PVector> newVertices = verticesFromEdges(edges);
        
        cell.label = \"\" + count + \"\\n\";
        List<List<PVector>> cleanEdges = new ArrayList<>(count);
        // Clear self-intersection if found https://stackoverflow.com/a/7785719
        boolean previousBad = false;
        for (int i=-1; i<count; ++i) \{
            PVector na = newVertices.get((i+count-1) % count);
            PVector nb = newVertices.get((i+count) % count);
            PVector nc = newVertices.get((i+1) % count);
            PVector nba = na.copy().sub(nb);
            PVector nbc = nc.copy().sub(nb); 
            PVector nCross = nbc.copy().cross(nba);

            PVector oa = vertices.get((i+count-1) % count);
            PVector ob = vertices.get((i+count) % count);
            PVector oc = vertices.get((i+1) % count);
            PVector oba = oa.copy().sub(ob);
            PVector obc = oc.copy().sub(ob);
            PVector oCross = obc.copy().cross(oba);

            boolean bad = Math.signum(nCross.z) != Math.signum(oCross.z);
            if (i != -1) \{
                if(bad && !previousBad) \{
                    //cell.label += String.format(\"%.1f\\n\", nCross.z);
                    cell.label += \"-\\n\";
                    previousBad = true;
                \} else \{
                    cleanEdges.add(Arrays.asList(nb, nc));
                    cell.label += \"+\\n\";
                    previousBad = false;
                \}
            \} else \{
                previousBad = bad;
            \}

        \}
        newVertices = verticesFromEdges(cleanEdges);
        
        cell.vertices = newVertices.size() > 2 ? newVertices : Collections.emptyList();
    \}
    
    /**
     * Move edge towards centre https://stackoverflow.com/a/15187473
     * 
     * @param a first edge point
     * @param b second edge point
     * @param c centre
     * @param ew distance (edge half width)
     * @return two new points
     */
    List<PVector> moveEdge(PVector a, PVector b, PVector c, double ew) \{
        double t = ((c.x-a.x)*(b.x-a.x)+(c.y-a.y)*(b.y-a.y))
            / (pow(b.x-a.x, 2)+pow(b.y-a.y, 2));
        // d - base of the perpendicular from c to line a-b
        PVector d = new PVector(a.x+t*(b.x-a.x), a.y+t*(b.y-a.y));
        double k = ew / c.dist(d);
        return Arrays.asList(
            new PVector(a.x+k*(c.x-d.x), a.y+k*(c.y-d.y)),
            new PVector(b.x+k*(c.x-d.x), b.y+k*(c.y-d.y)));
    \}
    
    /**
     * https://algorithmtutor.com/Computational-Geometry/Check-if-a-point-is-inside-a-polygon/
     * 
     * @param polygon
     * @param point
     * @return 
     */
    boolean isWithinPolygon(List<PVector> polygon, PVector point) \{
        List<Double> as = new ArrayList<>(polygon.size());
        List<Double> bs = new ArrayList<>(polygon.size());
        List<Double> cs = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            PVector p1 = polygon.get(i);
            PVector p2 = polygon.get((i+1)%polygon.size());
            double a = -(p2.y - p1.y);
            double b = p2.x - p1.x;
            double c = -(a*p1.x + b*p1.y);
            as.add(a);
            bs.add(b);
            cs.add(c);
        \}
        List<Double> ds = new ArrayList<>(polygon.size());
        for(int i=0; i<polygon.size(); ++i) \{
            double d = as.get(i)*point.x + bs.get(i)*point.y + cs.get(i);
            ds.add(d);
        \}
        boolean t1 = ds.stream().allMatch(d -> d <= EDGE_THRESHOLD);
        boolean t2 = ds.stream().allMatch(d -> d >= -EDGE_THRESHOLD);
        return t1 || t2;
    \}
    
    /**
     * find new intersection points of moved edges
     * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
     */
    List<PVector> verticesFromEdges(List<List<PVector>> edges) \{
        List<PVector> vertices = new ArrayList<>(edges.size());
        for (int i=0; i<edges.size(); ++i) \{
            List<PVector> e1 = edges.get(i);
            List<PVector> e2 = edges.get((i+1) % edges.size());
            
            PVector v1 = e1.get(0), v2 = e1.get(1), v3 = e2.get(0), v4 = e2.get(1);
            double denominator = (v1.x-v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x-v4.x);
            double x = ((v1.x*v2.y-v1.y*v2.x)*(v3.x-v4.x)-(v1.x-v2.x)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            double y = ((v1.x*v2.y-v1.y*v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x*v4.y-v3.y*v4.x))
                    / denominator;
            vertices.add(new PVector(x, y));
        \}
        return vertices;
    \}
    
    void drawCells() \{
        // Filtering on valid unnecessary
        cells.stream().filter(Cell::valid).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            noStroke();
            cell.vertices.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(REPLACE);
        textSize(10);
        fill(255, 0, 0);
        for(int i=0; i<cells.size(); ++i) \{
            if(cells.get(i).valid()) \{
                text(cells.get(i).label + i, cells.get(i).centre.x, cells.get(i).centre.y);
            \}
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.fill(255);
            outEdges.noStroke();
            outEdges.beginShape();

            PShape borders = outEdges.createShape().beginShape()
                    .vertex(0, height).vertex(0, 0)
                    .vertex(width, 0).vertex(width, height);
            cells.stream().filter(Cell::valid).forEach(cell -> \{
                borders.beginContour();
                cell.vertices.forEach(v -> borders.vertex(v.x, v.y));
                borders.endContour();
            \});
            borders.endShape();
            outEdges.shape(borders);
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}
    
    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        String label = \"\";
        
        List<PVector> vertices;
        PVector centre;
        
        Cell(int no, PImage in, PVector colour) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
        \}
        
        boolean valid() \{
            return null != vertices && null != centre;
        \}
    \}
"
    .cells-inputs 4
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 19.311472026808715
    .draw-cells true
    .draw-centers true
    .just-colours false
  }
  @ ./noise-1 video:source:noise {
    #%graph.x 396
    #%graph.y 504
  }
  @ ./send-1 core:routing:send {
    #%graph.x 171
    #%graph.y 784
    .address /main-out/voronoi-renderer1.voronoi-far-data
  }
  ~ ./xfader-1!out ./screen!in
  ~ ./strobe-timer!out ./voronoi-sender!move-cells
  ~ ./voronoi-renderer1!out ./xfader-1!in-2
  ~ ./data-receive!out ./screen!in
  ~ ./data-send!out ./data-receive!data-in
  ~ ./white!out ./voronoi-renderer!in-0
  ~ ./white!out ./voronoi-renderer!in-edges
  ~ ./strobe-timer!out ./voronoi-generator!move-cells
  ~ ./white!out ./voronoi-renderer1!in-0
  ~ ./noise-1!out ./voronoi-renderer1!in-edges
  ~ ./noise-1!out ./voronoi-renderer1!in-1
  ~ ./voronoi-renderer!out ./xfader-1!in-1
  ~ ./voronoi-generator!voronoi-data-out ./voronoi-renderer!voronoi-data
  ~ ./voronoi-generator!vor-out ./send-1!in
}
