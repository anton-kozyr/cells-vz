@ /video root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 1920
  .height 1200
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1313
    #%graph.y 365
    .device 2
    .always-on-top true
    .undecorated true
    .show-cursor true
  }
  @ ./voronoi-p2d video:gl:p2d {
    #%graph.x 980
    #%graph.y 89
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;


    static final int MAX_CELLS_COUNT = 40;
    static final double EDGE_THRESHOLD = 0.1;
    static final String ALL = \"All\";
    static final String ONE_BY_ONE = \"One by one\";
    static final String RANDOMLY = \"Randomly\";
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    @In(5) PImage in5;
    @In(6) PImage in6;
    @In(7) PImage inEdges;
   
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    
    @P(0) @Type.String(allowed = \{ALL, ONE_BY_ONE, RANDOMLY\}, def = RANDOMLY) String movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) double timeToMove;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"updateCellsCount\") int cellsCount;
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) @OnChange(\"updateCellsInputs\") int cellsInputs;
    @P(12) @Type.String(allowed = \{RANDOMLY, CYCLE, LAST_INPUT\}) @OnChange(\"updateCellsInputs\") String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;

    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    
    @P(19) @Type.Boolean(def = true) boolean justColours;
    
    @Inject Ref<List<PVector>> coloursRef;
    
    List<Cell> cells = new ArrayList<>();
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PointD>> pointsRef;
    
    // Coordinates of cell vertices
    double\[\]\[\] vertices;
    
    // Coordinates of cell edges
    double\[\]\[\] edges;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y;

    
    
    // Initialisation

    @Override public void setup() \{
        initRefs();
        updateCellsInputs();
        updateCellsCount();
    \}
    
    void initRefs() \{ 
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        pointsRef.init(CopyOnWriteArrayList::new);
    \}
    
    void updateCellsInputs() \{
        PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        Random r = new Random();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            int inNo;
            if(LAST_INPUT.equals(inputsToCells)) \{
                inNo = min(i, cellsInputs-1);
            \} else if (CYCLE.equals(inputsToCells)) \{
                inNo = i % cellsInputs;
            \} else \{ // if RANDOM
                inNo = r.nextInt(cellsInputs);
            \}
            Cell cell = new Cell(
                    i,
                    ins\[inNo\], 
                    coloursRef.get().get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]);
            newCells.add(cell);
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        pointsRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Arrays.asList(newPoints));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PointD point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}

    
    
    // Drawing
    
    @Override public void draw() \{
        updateCellsGeometry();
        if(drawCells) \{
            drawCells();
        \}
        drawEdges();
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = pointsRef.get().get(i);
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                pointsRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved || vertices == null) \{
            recalculateVoronoiRegions();
        \}
    \}
    
    void drawCells() \{
        cells.subList(0, cellsCount).forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour;
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in);
            \}
            strokeWeight(edgeWidth);
            stroke(0);
            double\[\] coords = vertices\[cell.no\];
            for(int i=0; i<coords.length/2; i+=1) \{
                double x = coords\[i*2\];
                double y = coords\[i*2+1\];
                vertex(x, y, x, y);
            \}
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
//            blendMode(REPLACE);
//            fill(255);
//            noStroke();
//            double dotSize = 20;
//            pointsRef.get().forEach(p -> 
//                rect(p.x-dotSize/2, p.y-dotSize/2, dotSize, dotSize)
//            );
        blendMode(REPLACE);
        textSize(10);
        fill(255);
        for(int i=0; i<pointsRef.get().size(); ++i) \{
            PointD p = pointsRef.get().get(i);
            text(i, p.x, p.y);
        \}
    \}
    
    void drawEdges() \{
        if(edgeWidth > EDGE_THRESHOLD) \{
            outEdges.beginDraw();
            outEdges.blendMode(REPLACE);
            outEdges.strokeWeight(edgeWidth);
            outEdges.stroke(255);
            
            for (int i=0; i<edges.length; ++i) \{
                double\[\] edge = edges\[i\];
                outEdges.line(edge\[0\], edge\[1\], edge\[2\], edge\[3\]);
            \}
            
            if (!justColours) \{
                outEdges.blendMode(MULTIPLY);
                outEdges.image(inEdges, 0, 0);
            \}
            outEdges.endDraw();
            blendMode(ADD);
            image(outEdges, 0, 0);
        \}
    \}

    

    // Cell movement
    
    @T(1) public void moveCells() \{
        if (movements.equals(ALL)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(ONE_BY_ONE)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(RANDOMLY)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    @T(2) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    // Cell count manipulation
    @T(3) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        VoronoiResults results = Voronoi.findAll(pointsRef.get().toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        double\[\]\[\] newCoords = new double\[regions.length\]\[\];
        for(int i = 0; i<regions.length; ++i) \{
            newCoords\[i\] = PointD.toDoubles(regions\[i\]);
        \}
        
        double newEdges\[\]\[\] = new double\[results.voronoiEdges.length\]\[\];
        for (int i = 0; i<results.voronoiEdges.length; ++i) \{
            VoronoiEdge edge = results.voronoiEdges\[i\];
            newEdges\[i\] = PointD.toDoubles(
                    results.voronoiVertices\[edge.vertex1\], 
                    results.voronoiVertices\[edge.vertex2\]);
        \}

        vertices = newCoords;
        edges = newEdges;
    \}



    // Cell container

    static class Cell \{
        final int no;
        final PImage in;
        final PVector colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, PImage in, PVector colour, Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
"
    .movement-speed 3.975462306971262
    .time-to-move 0.2
    .cells-count 35
    .cells-inputs 7
    .inputs-to-cells "Cycle inputs over cells"
    .edge-width 8
    .draw-cells true
    .just-colours false
  }
  @ ./colours core:container {
    #%graph.x 338
    #%graph.y -111
    #%praxis.version 4.1.1
    @ ./colour-1 video:gl:p2d {
      #%graph.x 159
      #%graph.y 20
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
     
    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#658395"
      .red 101.0
      .green 131.0
      .blue 149.0
      .hue 0.5625
      .saturation 0.3221476376056671
      .brightness 0.5843137502670288
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-3 video:gl:p2d {
      #%graph.x 435
      #%graph.y 120
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @P(20) @Type.Boolean(def=true) boolean on;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#883E86"
      .red 136.0
      .green 62.0
      .blue 134.0
      .hue 0.837837815284729
      .saturation 0.5441176295280457
      .brightness 0.5333333611488342
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-4 video:gl:p2d {
      #%graph.x 573
      #%graph.y 170
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
     
    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#FBD06B"
      .red 251.0
      .green 208.0
      .blue 107.0
      .hue 0.11689814925193787
      .saturation 0.5737051963806152
      .brightness 0.9843137264251709
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-5 video:gl:p2d {
      #%graph.x 711
      #%graph.y 220
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
     
    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#769F85"
      .red 118.0
      .green 159.0
      .blue 133.0
      .hue 0.3943089544773102
      .saturation 0.2578616440296173
      .brightness 0.6235294342041016
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-6 video:gl:p2d {
      #%graph.x 849
      #%graph.y 270
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
     
    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#FF6530"
      .red 255.0
      .green 101.0
      .blue 48.0
      .hue 0.04267311096191406
      .saturation 0.8117647171020508
      .brightness 1.0
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-2 video:gl:p2d {
      #%graph.x 297
      #%graph.y 70
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @P(20) @Type.Boolean(def=true) boolean on;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#D84248"
      .red 216.0
      .green 66.0
      .blue 72.0
      .hue 0.9933333396911621
      .saturation 0.6944444179534912
      .brightness 0.8470588326454163
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-0 video:gl:p2d {
      #%graph.x 21
      #%graph.y -30
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @P(20) @Type.Boolean(def=true) boolean on;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#2F8CB6"
      .red 47.0
      .green 140.0
      .blue 182.0
      .hue 0.5518518090248108
      .saturation 0.7417582273483276
      .brightness 0.7137255072593689
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./colour-7 video:gl:p2d {
      #%graph.x 987
      #%graph.y 320
      .code "import java.awt.Color;


    @P(0) @Type.String @OnChange(\"onHexRGB\") String hexRGB;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
     
    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    void onHexRGB() \{
        int h = hexRGB.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRGB.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRGB.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRGB.substring(h + 4, h + 6), 16);
        onRGB();
    \}
    
    void setHEX() \{
        hexRGB = \"#\" + 
            Integer.toHexString(
                    new Color((int)red, (int)green, (int)blue).getRGB() 
                            & 0xffffff)
                .toUpperCase();
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        setHEX();
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        setHEX();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .hex-rgb "#0"
      .fragment "uniform vec3 colour;

void main() \{
    gl_FragColor = vec4( colour.x/255, colour.y/255, colour.z/255, 1.0 );
\}"
      .on false
    }
    @ ./out-0 video:container:out {
      #%graph.x 1180
      #%graph.y -30
    }
    @ ./out-1 video:container:out {
      #%graph.x 1180
      #%graph.y 20
    }
    @ ./out-2 video:container:out {
      #%graph.x 1180
      #%graph.y 70
    }
    @ ./out-3 video:container:out {
      #%graph.x 1180
      #%graph.y 120
    }
    @ ./out-4 video:container:out {
      #%graph.x 1180
      #%graph.y 170
    }
    @ ./out-5 video:container:out {
      #%graph.x 1180
      #%graph.y 220
    }
    @ ./out-6 video:container:out {
      #%graph.x 1180
      #%graph.y 270
    }
    @ ./out-7 video:container:out {
      #%graph.x 1180
      #%graph.y 320
    }
    @ ./in-0 core:container:in {
      #%graph.x -249
      #%graph.y 20
    }
    @ ./in-1 core:container:in {
      #%graph.x -249
      #%graph.y 70
    }
    @ ./in-2 core:container:in {
      #%graph.x -249
      #%graph.y 120
    }
    @ ./in-3 core:container:in {
      #%graph.x -249
      #%graph.y 170
    }
    @ ./in-4 core:container:in {
      #%graph.x -249
      #%graph.y 220
    }
    @ ./in-5 core:container:in {
      #%graph.x -249
      #%graph.y 270
    }
    @ ./in-6 core:container:in {
      #%graph.x -249
      #%graph.y 320
    }
    @ ./in-7 core:container:in {
      #%graph.x -249
      #%graph.y 370
    }
    @ ./in-switch core:container:in {
      #%graph.x -249
      #%graph.y 460
    }
    ~ ./colour-0!out ./out-0!in
    ~ ./colour-1!out ./out-1!in
    ~ ./colour-2!out ./out-2!in
    ~ ./colour-3!out ./out-3!in
    ~ ./colour-4!out ./out-4!in
    ~ ./colour-5!out ./out-5!in
    ~ ./colour-6!out ./out-6!in
    ~ ./colour-7!out ./out-7!in
    ~ ./in-1!out ./colour-1!hex-rgb
    ~ ./in-0!out ./colour-0!hex-rgb
    ~ ./in-2!out ./colour-2!hex-rgb
    ~ ./in-3!out ./colour-3!hex-rgb
    ~ ./in-4!out ./colour-4!hex-rgb
    ~ ./in-5!out ./colour-5!hex-rgb
    ~ ./in-6!out ./colour-6!hex-rgb
    ~ ./in-7!out ./colour-7!hex-rgb
    ~ ./in-switch!out ./colour-0!on
    ~ ./in-switch!out ./colour-1!on
    ~ ./in-switch!out ./colour-2!on
    ~ ./in-switch!out ./colour-3!on
    ~ ./in-switch!out ./colour-4!on
    ~ ./in-switch!out ./colour-5!on
    ~ ./in-switch!out ./colour-6!on
    ~ ./in-switch!out ./colour-7!on
  }
  @ ./strobes core:container {
    #%graph.x 336
    #%graph.y 606
    #%praxis.version 4.1.1
    @ ./strobe-0 video:gl:p2d {
      #%graph.x 92
      #%graph.y -3
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-0 video:container:out {
      #%graph.x 1301
      #%graph.y -3
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x 232
      #%graph.y 47
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-1 video:container:out {
      #%graph.x 1301
      #%graph.y 47
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x 372
      #%graph.y 97
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-2 video:container:out {
      #%graph.x 1301
      #%graph.y 97
    }
    @ ./strobe-3 video:gl:p2d {
      #%graph.x 512
      #%graph.y 147
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-3 video:container:out {
      #%graph.x 1301
      #%graph.y 147
    }
    @ ./strobe-4 video:gl:p2d {
      #%graph.x 652
      #%graph.y 197
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-4 video:container:out {
      #%graph.x 1301
      #%graph.y 197
    }
    @ ./strobe-5 video:gl:p2d {
      #%graph.x 792
      #%graph.y 247
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-5 video:container:out {
      #%graph.x 1301
      #%graph.y 247
    }
    @ ./strobe-6 video:gl:p2d {
      #%graph.x 932
      #%graph.y 297
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease .2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-6 video:container:out {
      #%graph.x 1301
      #%graph.y 297
    }
    @ ./strobe-7 video:gl:p2d {
      #%graph.x 1072
      #%graph.y 347
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./out-7 video:container:out {
      #%graph.x 1301
      #%graph.y 347
    }
    @ ./in-0 core:container:in {
      #%graph.x -134
      #%graph.y -3
    }
    @ ./in-1 core:container:in {
      #%graph.x -134
      #%graph.y 47
    }
    @ ./in-2 core:container:in {
      #%graph.x -134
      #%graph.y 97
    }
    @ ./in-3 core:container:in {
      #%graph.x -134
      #%graph.y 147
    }
    @ ./in-4 core:container:in {
      #%graph.x -134
      #%graph.y 197
    }
    @ ./in-5 core:container:in {
      #%graph.x -134
      #%graph.y 247
    }
    @ ./in-6 core:container:in {
      #%graph.x -134
      #%graph.y 297
    }
    @ ./in-7 core:container:in {
      #%graph.x -134
      #%graph.y 347
    }
    ~ ./strobe-0!out ./out-0!in
    ~ ./strobe-1!out ./out-1!in
    ~ ./strobe-2!out ./out-2!in
    ~ ./strobe-3!out ./out-3!in
    ~ ./strobe-4!out ./out-4!in
    ~ ./strobe-5!out ./out-5!in
    ~ ./strobe-6!out ./out-6!in
    ~ ./strobe-7!out ./out-7!in
    ~ ./in-0!out ./strobe-0!strobe
    ~ ./in-1!out ./strobe-1!strobe
    ~ ./in-2!out ./strobe-2!strobe
    ~ ./in-3!out ./strobe-3!strobe
    ~ ./in-4!out ./strobe-4!strobe
    ~ ./in-5!out ./strobe-5!strobe
    ~ ./in-6!out ./strobe-6!strobe
    ~ ./in-7!out ./strobe-7!strobe
  }
  @ ./strobe-control core:timing:timer {
    #%graph.x 103
    #%graph.y 606
    .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(4) Output out4;
    @Out(5) Output out5;
    @Out(6) Output out6;
    @Out(7) Output out7;
    
    @T(0) public void strobe0() \{ out0.send(); \}
    @T(1) public void strobe1() \{ out1.send(); \}
    @T(2) public void strobe2() \{ out2.send(); \}
    @T(3) public void strobe3() \{ out3.send(); \}
    @T(4) public void strobe4() \{ out4.send(); \}
    @T(5) public void strobe5() \{ out5.send(); \}
    @T(6) public void strobe6() \{ out6.send(); \}
    @T(7) public void strobe7() \{ out7.send(); \}
    
"
  }
  @ ./colour-control core:variable {
    #%graph.x 105
    #%graph.y 89
    .code "

    @P(0) @OnChange(\"send\") String rgb0;
    @P(1) @OnChange(\"send\") String rgb1;
    @P(2) @OnChange(\"send\") String rgb2;
    @P(3) @OnChange(\"send\") String rgb3;
    @P(4) @OnChange(\"send\") String rgb4;
    @P(5) @OnChange(\"send\") String rgb5;
    @P(6) @OnChange(\"send\") String rgb6;
    @P(7) @OnChange(\"send\") String rgb7;
    @P(10) @Type.Boolean(def=true) @OnChange(\"onOff\") boolean on;
    
    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(4) Output out4;
    @Out(5) Output out5;
    @Out(6) Output out6;
    @Out(7) Output out7;
    @Out(10) Output outOn;
        
    void send() \{
        out0.send(rgb0);
        out1.send(rgb1);
        out2.send(rgb2);
        out3.send(rgb3);
        out4.send(rgb4);
        out5.send(rgb5);
        out6.send(rgb6);
        out7.send(rgb7);
    \}
    
    @Override
    public void starting() \{
        onOff();
    \}
    
    void onOff() \{
        outOn.send(on);
    \}
    
"
    .rgb-0 "#2f8cb6"
    .rgb-1 "#658395"
    .rgb-2 "#d84248"
    .rgb-3 "#883e86"
    .rgb-4 "#fbd06b"
    .rgb-5 "#769f85"
    .rgb-6 "#ff6530"
    .rgb-7 000000
    .on false
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x -609
    #%graph.y 290
    .period .25
  }
  @ ./trigger-splitter core:custom {
    #%graph.x -333
    #%graph.y 290
    .code "
    @P(0) @Type.Number(def=0) @ReadOnly Property counter;
    
    @Out(0) Output outEach;
    @Out(1) Output out1Of2;
    @Out(2) Output out2Of2;
    @Out(3) Output out1Of4;
    @Out(4) Output out2Of4;
    @Out(5) Output out3Of4;
    @Out(6) Output out4Of4;
    @Out(7) Output out1Of8;
    @Out(8) Output out2Of8;
    @Out(9) Output out3Of8;
    @Out(10) Output out4Of8;
    @Out(11) Output out5Of8;
    @Out(12) Output out6Of8;
    @Out(13) Output out7Of8;
    @Out(14) Output out8Of8;
    
    @T(0) void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch(count) \{
            case 0: out1Of2.send(); out1Of4.send(); out1Of8.send(); break;
            case 1: out2Of2.send(); out2Of4.send(); out2Of8.send(); break;
            case 2: out1Of2.send(); out3Of4.send(); out3Of8.send(); break;
            case 3: out2Of2.send(); out4Of4.send(); out4Of8.send(); break;
            case 4: out1Of2.send(); out1Of4.send(); out5Of8.send(); break;
            case 5: out2Of2.send(); out2Of4.send(); out6Of8.send(); break;
            case 6: out1Of2.send(); out3Of4.send(); out7Of8.send(); break;
            case 7: out2Of2.send(); out4Of4.send(); out8Of8.send(); break;
        \}
    \}
    
    @T(1) void reset() \{
        counter.set(0);
    \}
"
  }
  @ ./warping video:gl:p2d {
    #%graph.x 612
    #%graph.y -368
    .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", millis()/2);
        shader.set(\"resolution\", width, height);
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
    .fragment "// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;

float random (in vec2 _st) \{
    return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) \{
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
\}

#define NUM_OCTAVES 5

float fbm ( in vec2 _st) \{
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5),
                    -sin(0.5), cos(0.50));
    for (int i = 0; i < NUM_OCTAVES; ++i) \{
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    \}
    return v;
\}

void main() \{
    float ktime = pow(time, 0.6); // change power to regulate speed
    vec2 st = gl_FragCoord.xy/resolution.xy*3.;
    st.x += pow(time, 0.4);
//     st += st * abs(sin(time*0.1)*3.0);
    vec3 color = vec3(0.0);

    vec2 q = vec2(0.);
    q.x = fbm( st + .0*ktime);
    q.y = fbm( st + vec2(1.0));

    vec2 r = vec2(0.);
    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*ktime );
    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*ktime);

    float f = fbm(st+r);

    color = mix(vec3(0.101961,0.619608,0.666667),
                vec3(0.666667,0.666667,0.498039),
                clamp((f*f)*4.0,0.0,1.0));

    color = mix(color,
                vec3(0.0,0,0.164706),
                clamp(length(q),0.0,1.0));

    color = mix(color,
                vec3(0.666667,1,1),
                clamp(length(r.x),0.0,1.0));

    gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);
\}
"
  }
  @ ./lines video:gl:p2d {
    #%graph.x 79
    #%graph.y -37
    .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property timer;
    double angle;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"position\", d(timer));
        shader.set(\"angle\", angle);
    \}
    
    @T(1) void animate() \{
        timer.set(0);
        timer.to(1).in(0.5).linear();
        //timer.animator().whenDone(p -> animate());
        angle = random(-PI, PI);
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
        //animate();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
    .fragment "#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 resolution;
uniform vec2 mouse;
uniform float position;
uniform float angle;

float random (float seed) \{
    return fract(sin(dot(vec2(seed, 1.0),
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

float plot(vec2 st, float pct)\{
  return  smoothstep( pct-0.02, pct, st.y) -
          smoothstep( pct, pct+0.02, st.y);
\}

//  Function from Iñigo Quiles
//  www.iquilezles.org/www/articles/functions/functions.htm
float cubicPulse( float c, float w, float x )\{
    x = abs(x - c);
    if( x>w ) return 0.0;
    x /= w;
    return 1.0 - x*x*(3.0-2.0*x);
\}

mat2 rotate2d(float _angle)\{
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
\}

void main() \{
    if(1 == position) \{
        gl_FragColor = vec4(0.0, 0.0, 0.0,1.0);
        return;
    \}

    vec2 st = gl_FragCoord.xy/max(resolution.x, resolution.y);
    st -= vec2(0.5);
    st *= rotate2d(angle);
    st += vec2(0.5);

    // Smooth interpolation between 0.1 and 0.9
    float y = cubicPulse(0.5,0.2,(st.x+position*1.2-0.5));
    vec3 color = vec3(y);

    float pct = 0; //plot(st,y);
    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

    gl_FragColor = vec4(color,1.0);
\}
"
  }
  @ ./squares video:gl:p2d {
    #%graph.x -55
    #%graph.y -339
    .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    double rand;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"rand\", rand);
    \}
    
    @T(1) void shuffle() \{
        rand = random(100);
    \}
    
    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
    .fragment "// Author @patriciogv - 2015
// Title: Mosaic

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform float rand;

float random (vec2 st) \{
    return fract(sin(dot(st.xy*rand,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

void main() \{
    vec2 st = gl_FragCoord.xy/resolution.xy;

    st *= 10.0; // Scale the coordinate system by 10
    vec2 ipos = floor(st);  // get the integer coords
    vec2 fpos = fract(st);  // get the fractional coords

    // Assign a random value based on the integer coord
    vec3 color = vec3(random(ipos));

    // Uncomment to see the subdivided grid
    // color = vec3(fpos,0.0);

    gl_FragColor = vec4(color,1.0);
\}"
  }
  @ ./video-splitter core:container {
    #%graph.x 874
    #%graph.y -383
    #%praxis.version 4.1.1
    @ ./out-0 video:container:out {
      #%graph.x 1012
      #%graph.y 66
    }
    @ ./out-1 video:container:out {
      #%graph.x 1012
      #%graph.y 116
    }
    @ ./out-2 video:container:out {
      #%graph.x 1012
      #%graph.y 166
    }
    @ ./out-3 video:container:out {
      #%graph.x 1012
      #%graph.y 216
    }
    @ ./out-4 video:container:out {
      #%graph.x 1012
      #%graph.y 266
    }
    @ ./out-5 video:container:out {
      #%graph.x 1012
      #%graph.y 316
    }
    @ ./out-6 video:container:out {
      #%graph.x 1012
      #%graph.y 366
    }
    @ ./in-for-all video:container:in {
      #%graph.x 137
      #%graph.y 66
    }
    @ ./switch-0 video:custom {
      #%graph.x 583
      #%graph.y 28
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-1 video:custom {
      #%graph.x 583
      #%graph.y 128
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-2 video:custom {
      #%graph.x 583
      #%graph.y 228
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-3 video:custom {
      #%graph.x 583
      #%graph.y 328
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-4 video:custom {
      #%graph.x 583
      #%graph.y 428
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-5 video:custom {
      #%graph.x 583
      #%graph.y 528
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-6 video:custom {
      #%graph.x 583
      #%graph.y 628
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch core:container:in {
      #%graph.x 146
      #%graph.y 253
    }
    ~ ./switch-0!out ./out-0!in
    ~ ./in-for-all!out ./switch-0!in
    ~ ./in-for-all!out ./switch-1!in
    ~ ./in-for-all!out ./switch-2!in
    ~ ./in-for-all!out ./switch-3!in
    ~ ./in-for-all!out ./switch-4!in
    ~ ./in-for-all!out ./switch-5!in
    ~ ./in-for-all!out ./switch-6!in
    ~ ./switch-1!out ./out-1!in
    ~ ./switch-2!out ./out-2!in
    ~ ./switch-3!out ./out-3!in
    ~ ./switch-4!out ./out-4!in
    ~ ./switch-5!out ./out-5!in
    ~ ./switch-6!out ./out-6!in
    ~ ./switch!out ./switch-0!on
    ~ ./switch!out ./switch-1!on
    ~ ./switch!out ./switch-2!on
    ~ ./switch!out ./switch-3!on
    ~ ./switch!out ./switch-4!on
    ~ ./switch!out ./switch-5!on
    ~ ./switch!out ./switch-6!on
  }
  @ ./corner-0 core:custom {
    #%graph.x 1643
    #%graph.y -805
  }
  @ ./corner-1 core:custom {
    #%graph.x -783
    #%graph.y -805
  }
  @ ./corner-2 core:custom {
    #%graph.x 1783
    #%graph.y 1121
  }
  @ ./corner-3 core:custom {
    #%graph.x -783
    #%graph.y 1121
  }
  @ ./vide-switch core:property {
    #%graph.x 612
    #%graph.y -295
    .code "

    @P(1) @Type.Boolean(def=true) @OnChange(\"onOff\") Property on;

    @Out(1) Output out;
    @Out(2) Output notOut;
    
    @Override
    public void starting() \{
        onOff();
    \}
    
    void onOff() \{
        out.send(on.getBoolean());
        notOut.send(!on.getBoolean());
    \}
"
  }
  @ ./video-splitter-2 core:container {
    #%graph.x 171
    #%graph.y -401
    #%praxis.version 4.1.1
    @ ./out-0 video:container:out {
      #%graph.x 1012
      #%graph.y 66
    }
    @ ./out-1 video:container:out {
      #%graph.x 1012
      #%graph.y 116
    }
    @ ./out-2 video:container:out {
      #%graph.x 1012
      #%graph.y 166
    }
    @ ./out-3 video:container:out {
      #%graph.x 1012
      #%graph.y 216
    }
    @ ./out-4 video:container:out {
      #%graph.x 1012
      #%graph.y 266
    }
    @ ./out-5 video:container:out {
      #%graph.x 1012
      #%graph.y 316
    }
    @ ./out-6 video:container:out {
      #%graph.x 1012
      #%graph.y 366
    }
    @ ./in-for-all video:container:in {
      #%graph.x 137
      #%graph.y 66
    }
    @ ./switch-0 video:custom {
      #%graph.x 583
      #%graph.y 28
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-1 video:custom {
      #%graph.x 583
      #%graph.y 128
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-2 video:custom {
      #%graph.x 583
      #%graph.y 228
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-3 video:custom {
      #%graph.x 583
      #%graph.y 328
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-4 video:custom {
      #%graph.x 583
      #%graph.y 428
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-5 video:custom {
      #%graph.x 583
      #%graph.y 528
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch-6 video:custom {
      #%graph.x 583
      #%graph.y 628
      .code "
    @In(0) PImage in;
    @P(1) @Type.Boolean(def=true) boolean on;
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
        if(on) \{
            copy(in);
            release(in);
        \}
    \}
    
"
    }
    @ ./switch core:container:in {
      #%graph.x 146
      #%graph.y 253
    }
    ~ ./switch-0!out ./out-0!in
    ~ ./in-for-all!out ./switch-0!in
    ~ ./in-for-all!out ./switch-1!in
    ~ ./in-for-all!out ./switch-2!in
    ~ ./in-for-all!out ./switch-3!in
    ~ ./in-for-all!out ./switch-4!in
    ~ ./in-for-all!out ./switch-5!in
    ~ ./in-for-all!out ./switch-6!in
    ~ ./switch-1!out ./out-1!in
    ~ ./switch-2!out ./out-2!in
    ~ ./switch-3!out ./out-3!in
    ~ ./switch-4!out ./out-4!in
    ~ ./switch-5!out ./out-5!in
    ~ ./switch-6!out ./out-6!in
    ~ ./switch!out ./switch-0!on
    ~ ./switch!out ./switch-1!on
    ~ ./switch!out ./switch-2!on
    ~ ./switch!out ./switch-3!on
    ~ ./switch!out ./switch-4!on
    ~ ./switch!out ./switch-5!on
    ~ ./switch!out ./switch-6!on
  }
  @ ./vide-switch-1 core:property {
    #%graph.x -76
    #%graph.y -208
    .code "

    @P(1) @Type.Boolean(def=true) @OnChange(\"onOff\") Property on;

    @Out(1) Output out;
    
    @Override
    public void starting() \{
        onOff();
    \}
    
    void onOff() \{
        out.send(on.getBoolean());
    \}
    
"
  }
  @ ./white video:gl:p2d {
    #%graph.x 516
    #%graph.y 264
    .code "import java.awt.Color;


    @P(20) @Type.Boolean(def=true) boolean on;
   
    @Override
    public void setup() \{
        noStroke();
        fill(255);
    \}

    @Override
    public void draw() \{
        if (!on) \{
            return;
        \}
        rect(0, 0, width, height);
    \}
"
    .on false
  }
  @ ./taptempo core:custom {
    #%graph.x -593
    #%graph.y 27
    #%graph.colors Orange
    #%graph.comment Tap tempo component\ntrig : trigger on the beat\nunit : provides a unit interval\npare with tapdiv to slow down unit over \nmultiple beats, ie 4 beats
    .code "

    @P(1) @Type.Number(min = 0.001, max = 60, def = 1)
    double period;

    @P(2) @Type.Number @ReadOnly
    Property time;

    @P(3) @Type.Boolean() boolean playing = true;

    @Out(1) Output trig;
    @Out(2) Output unit;

    @Inject Property chrono;

    final int ARRAY_SIZE = 5;
    double\[\] timeArray = new double\[ARRAY_SIZE\];

    @Override
    public void update() \{
        if (!time.isAnimating() && playing) \{
            time.set(0).to(1).in(period);
            trig.send(1.0);
        \}
        unit.send(d(time));
    \}

    @T(0) void tap()\{
        if(d(chrono) < 12)\{
            for(int i = ARRAY_SIZE-1; i > 0; i--)\{
                timeArray\[i\] = timeArray\[i-1\];
            \}
            timeArray\[0\] = d(chrono);
            double _sum = 0;
            for(int i = 0; i < ARRAY_SIZE; i++)\{
                _sum += timeArray\[i\];
            \}
            period = (_sum/ARRAY_SIZE);
            time.animator().in(period);
        \}
        chrono.set(0).to(1000).in(1000);
    \}
    
    @T(1) void trigger()\{
        time.set(0).to(1).in(period);
        trig.send(1.0);
    \}
"
    .period 0.2277712018
    .playing true
  }
  @ ./tapdiv core:custom {
    #%graph.x -308
    #%graph.y 101
    #%graph.colors Orange
    .code "

    @P(1) @Type.Number(min = 0.00001, max = 60, def = 1)
    double divider;

    double out = 0;
    double previousOut = 0;

    double previous = 0;
    double tracker = 0;

    @Out(1) Output trig;
    @Out(2) Output unit;


    @In(1) void unitin(double ui)\{
        if(ui < previous) tracker++;
        previous = ui;
        out = ((tracker+ui)/divider) - (int)((tracker+ui)/divider);
        unit.send(out);
        if(previousOut > out) trig.send(1);
        previousOut = out;
    \}

"
    .divider .5
  }
  ~ ./voronoi-p2d!out ./screen!in
  ~ ./strobes!out-1 ./voronoi-p2d!in-1
  ~ ./strobes!out-2 ./voronoi-p2d!in-2
  ~ ./strobes!out-3 ./voronoi-p2d!in-3
  ~ ./strobes!out-4 ./voronoi-p2d!in-4
  ~ ./strobes!out-5 ./voronoi-p2d!in-5
  ~ ./strobes!out-6 ./voronoi-p2d!in-6
  ~ ./strobe-control!out-0 ./strobes!in-0
  ~ ./strobe-control!out-1 ./strobes!in-1
  ~ ./strobe-control!out-2 ./strobes!in-2
  ~ ./strobe-control!out-3 ./strobes!in-3
  ~ ./strobe-control!out-4 ./strobes!in-4
  ~ ./strobe-control!out-5 ./strobes!in-5
  ~ ./strobe-control!out-6 ./strobes!in-6
  ~ ./strobe-control!out-7 ./strobes!in-7
  ~ ./colour-control!out-0 ./colours!in-0
  ~ ./colour-control!out-1 ./colours!in-1
  ~ ./colour-control!out-2 ./colours!in-2
  ~ ./colour-control!out-3 ./colours!in-3
  ~ ./colour-control!out-4 ./colours!in-4
  ~ ./strobes!out-0 ./voronoi-p2d!in-0
  ~ ./colour-control!out-on ./colours!in-switch
  ~ ./warping!out ./video-splitter!in-for-all
  ~ ./video-splitter!out-0 ./voronoi-p2d!in-0
  ~ ./vide-switch!out ./video-splitter!switch
  ~ ./video-splitter!out-1 ./voronoi-p2d!in-1
  ~ ./video-splitter!out-2 ./voronoi-p2d!in-2
  ~ ./video-splitter!out-3 ./voronoi-p2d!in-3
  ~ ./video-splitter!out-4 ./voronoi-p2d!in-4
  ~ ./video-splitter!out-5 ./voronoi-p2d!in-5
  ~ ./video-splitter!out-6 ./voronoi-p2d!in-6
  ~ ./squares!out ./video-splitter-2!in-for-all
  ~ ./vide-switch-1!out ./video-splitter-2!switch
  ~ ./video-splitter-2!out-1 ./voronoi-p2d!in-1
  ~ ./white!out ./voronoi-p2d!in-edges
  ~ ./colours!out-7 ./voronoi-p2d!in-edges
  ~ ./video-splitter-2!out-2 ./voronoi-p2d!in-2
  ~ ./taptempo!trig ./trigger-splitter!trigger
  ~ ./strobes!out-7 ./voronoi-p2d!in-edges
  ~ ./colour-control!out-5 ./colours!in-5
  ~ ./colour-control!out-6 ./colours!in-6
  ~ ./colour-control!out-7 ./colours!in-7
  ~ ./colours!out-5 ./voronoi-p2d!in-5
  ~ ./trigger-splitter!out-2-of-2 ./squares!shuffle
  ~ ./taptempo!unit ./tapdiv!unitin
  ~ ./colours!out-2 ./voronoi-p2d!in-2
  ~ ./colours!out-1 ./voronoi-p2d!in-1
  ~ ./colours!out-0 ./voronoi-p2d!in-0
  ~ ./trigger-splitter!out-2-of-4 ./strobe-control!strobe-3
  ~ ./trigger-splitter!out-1-of-8 ./strobe-control!strobe-0
  ~ ./lines!out ./voronoi-p2d!in-edges
  ~ ./trigger-splitter!out-3-of-4 ./lines!animate
  ~ ./trigger-splitter!out-1-of-2 ./voronoi-p2d!move-cells
}
