@ /video root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 1920
  .height 1080
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 303
    #%graph.y -286
    .device 2
    .full-screen true
    .undecorated true
    .show-cursor true
  }
  @ ./x-fader video:xfader {
    #%graph.x 126
    #%graph.y -506
    .code "

    enum Mode \{Normal, Add, Difference, BitXor\};
    
    @In(0) PImage bw;
    @In(1) PImage clouds;
    @In(4) PImage colours;
    @In(5) PImage videos;
    
    @P(1) Mode mode;
    @P(2) @Type.Number(min=0, max=30, def=10) double xFadeTime;
    @P(3) @ReadOnly @Type.Number(min = 0, max = 1) Property mix;
    
    @Inject Ref<int\[\]> inIdsRef;
    
    @T(0) void reset() \{
        inIdsRef.apply(ins -> \{
           ins\[0\] = 0;
           ins\[1\] = 0;
           mix.set(0);
        \});
    \}
    
    @T(10) void toBw() \{
        mode = Mode.Normal;
        fadeTo(bw);
    \}
    
    @T(11) void toClouds() \{
        mode = Mode.Normal;
        fadeTo(clouds);
    \}
    
    @T(12) void toColours() \{
        mode = Mode.Normal;
        fadeTo(colours);
    \}
    
    @T(13) void toVideos() \{
        mode = Mode.Normal;
        fadeTo(videos);
    \}
    
    void fadeTo(PImage in) \{
        inIdsRef.apply(inIds -> \{
            inIds\[1\] = idByIn(in);
            log(INFO, \"From scene: \" + inIds\[0\] + \" to \" + inIds\[1\]);
            if (inIds\[0\] != inIds\[1\]) \{
                mix.set(0).to(1).in(xFadeTime).easeInOut().whenDone(mix -> \{
                    inIds\[0\] = inIds\[1\];
                    log(INFO, \"Active scene: \" + inIds\[0\] + \" \" + inIds\[1\]);
                \});
            \}
        \});
    \}
    
    @Override
    public void init() \{
        inIdsRef.init(() -> new int\[\] \{2, 2\});
        IntStream.range(0, max(ins().length, insNames().length)).forEach((int i) -> 
            attachRenderQuery(insNames()\[i\], rendering -> rendering && inActive(ins()\[i\])));
        attachRenderQuery(\"bw\", rendering -> rendering && inActive(bw));
        attachRenderQuery(\"clouds\", rendering -> rendering && inActive(clouds));
        attachRenderQuery(\"colours\", rendering -> rendering && inActive(colours));
    \}
    
    @Override
    public void draw() \{
        inIdsRef.apply(inIds -> \{
            PImage in0 = inById(inIds\[0\]);
            PImage in1 = inById(inIds\[1\]);
            if (d(mix) < 0.001) \{
                copy(in0);
                release(in0);
            \} else if (d(mix) > 0.999) \{
                copy(in1);
                release(in1);
            \} else if (mode == Mode.Normal) \{
                blendMode(ADD, 1 - d(mix));
                image(in0, 0, 0);
                blendMode(ADD, d(mix));
                image(in1, 0, 0);
            \} else \{
                drawBlended(in0, in1);
            \}
        \});
    \}
    
    void drawBlended(PImage in0, PImage in1) \{
        PImage fg, bg;
        double opacity;
        if (d(mix) > 0.5) \{
            fg = in0;
            bg = in1;
            opacity = (1.0 - d(mix)) * 2;
        \} else \{
            fg = in1;
            bg = in0;
            opacity = d(mix) * 2;
        \}
        copy(bg);
        release(bg);
        switch (mode) \{
            case Difference:
                blendMode(DIFFERENCE, opacity);
                break;
            case BitXor:
                blendMode(BITXOR, opacity);
                break;
            default:
                blendMode(ADD, opacity);
                break;
        \}
        image(fg, 0, 0);
    \}
    
    PImage\[\] ins() \{
        return new PImage\[\] \{ bw, clouds, colours, videos \};
    \}
    
    String\[\] insNames() \{
        return new String\[\] \{\"bw\", \"clouds\", \"colours\", \"videos\"\};
    \}

    int idByIn(PImage in) \{
        for(int i=0; i<ins().length; ++i) \{
            if(inById(i) == in) \{
                return i;
            \}
        \}
        return 0;
    \}
     
    PImage inById(int id) \{
        return ins()\[id\];
    \}
   
    boolean inActive(PImage in) \{
        return inById(inIdsRef.get()\[0\]) == in || inById(inIdsRef.get()\[1\]) == in;
    \}
"
    .x-fade-time 0.6521739130434783
  }
  @ ./voronoi-generator core:custom {
    #%graph.x -758
    #%graph.y -438
    #%graph.comment set width/height
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    enum Movements \{
        all, oneByOne, randomly
    \};
    
    @P(0) @OnChange(\"sendProperties\") Movements movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) @OnChange(\"sendProperties\") double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) @OnChange(\"sendProperties\") double timeToMove;
    @P(3) @Type.Boolean @OnChange(\"sendProperties\") boolean moveToCentre;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"onCellsCountChangedFromUI\") int cellsCount;

    @P(11) @Type.Integer(def=800) int width;
    @P(12) @Type.Integer(def=600) int height;
    
    @Out(100) Data.Out<PBytes> voronoiPipeOut;
    @Out(101) Output voronoiOut;
    @Out(102) Output propertiesOut;
    @AuxIn(101) @ReadOnly Input propertiesIn;
    
    List<Cell> cells = new ArrayList<>();
    
    // Cache of the encoded data to send
    PBytes voronoiBytes;
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x,
            m40x, m41x, m42x, m43x, m44x, m45x, m46x, m47x, m48x, m49x,
            m50x, m51x, m52x, m53x, m54x, m55x, m56x, m57x, m58x, m59x,
            m60x, m61x, m62x, m63x, m64x, m65x, m66x, m67x, m68x, m69x,
            m70x, m71x, m72x, m73x, m74x, m75x, m76x, m77x, m78x, m79x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y,
            m40y, m41y, m42y, m43y, m44y, m45y, m46y, m47y, m48y, m49y,
            m50y, m51y, m52y, m53y, m54y, m55y, m56y, m57y, m58y, m59y,
            m60y, m61y, m62y, m63y, m64y, m65y, m66y, m67y, m68y, m69y,
            m70y, m71y, m72y, m73y, m74y, m75y, m76y, m77y, m78y, m79y;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::encodeVoronoiData), voronoiPipeOut);
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        sendProperties();
    \}
    
    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\},
            \{m40x, m40y\}, \{m41x, m41y\}, \{m42x, m42y\}, \{m43x, m43y\}, \{m44x, m44y\}, 
            \{m45x, m45y\}, \{m46x, m46y\}, \{m47x, m47y\}, \{m48x, m48y\}, \{m49x, m49y\},
            \{m50x, m50y\}, \{m51x, m51y\}, \{m52x, m52y\}, \{m53x, m53y\}, \{m54x, m54y\}, 
            \{m55x, m55y\}, \{m56x, m56y\}, \{m57x, m57y\}, \{m58x, m58y\}, \{m59x, m59y\},
            \{m60x, m60y\}, \{m61x, m61y\}, \{m62x, m62y\}, \{m63x, m63y\}, \{m64x, m64y\}, 
            \{m65x, m65y\}, \{m66x, m66y\}, \{m67x, m67y\}, \{m68x, m68y\}, \{m69x, m69y\},
            \{m70x, m70y\}, \{m71x, m71y\}, \{m72x, m72y\}, \{m73x, m73y\}, \{m74x, m74y\}, 
            \{m75x, m75y\}, \{m76x, m76y\}, \{m77x, m77y\}, \{m78x, m78y\}, \{m79x, m79y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            newCells.add(new Cell(i, moves\[i\]\[0\], moves\[i\]\[1\]));
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}
    
    void onCellsCountChangedFromUI() \{
        updateCellsCount();
        sendProperties();
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();
            voronoiBytes = encodeVoronoiData();
            voronoiOut.send(voronoiBytes);
        \}
        sendProperties();
    \}

    // Cell movement
    
    @Inject int p = 0;
    
    @T(1)
    public void moveCells() \{
        if((!moveToCentre) || 0==p++%3) \{
            moveRandomly();
        \} else \{
            moveToCentre();
        \}
    \}
    
    @T(3)
    public void moveToCentre() \{
        cells.forEach(cell -> \{
            double angle = random(2*PI);
            double dist = random(height/5, height/2);
            double nx = dist*sin(angle);
            double ny = dist*cos(angle);
            double dx = width/2;
            double dy = height/2;
            cell.startMovingTo(nx+dx, ny+dy, timeToMove);
        \});
    \}
    
    @T(2)
    public void moveRandomly() \{
        if (movements.equals(Movements.all)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(Movements.oneByOne)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(Movements.randomly)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    
    @T(10) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    @T(11) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(-1000, -1000, width+1000, height+1000);
        List<PointD> centers = centresRef.get().subList(0, cellsCount).stream()
                .map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).polygon = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
    \}

    // Data encoded as following: 
    // int: cellsCount
    // for each cell:
    //   int: centre.x
    //   int: centre.y
    //   int: vertices count
    //   for each vertex:
    //     int: vertex.x
    //     int: vertex.y
    PBytes encodeVoronoiData() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(cellsCount);
            for(int i=0; i<cellsCount; ++i) \{
                PVector centre = centresRef.get().get(i);
                dos.writeDouble(centre.x);
                dos.writeDouble(centre.y);
                Cell cell = cells.get(i);
                dos.writeInt(cell.polygon.size());
                cell.polygon.forEach(v -> \{
                    try \{
                        dos.writeDouble(v.x);
                        dos.writeDouble(v.y);
                    \} catch (IOException ex) \{
                        throw new RuntimeException(ex);
                    \}
                \});
            \}
            dos.flush();
            PBytes bytes = os.toBytes();
            dos.close();
            return bytes;
        \} catch (Exception ex) \{
            log(ERROR, \"Voronoi data encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    
    // Sending and receiving all properties (for using with control element)
    
    void sendProperties() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(movements.ordinal());
            dos.writeDouble(movementSpeed);
            dos.writeDouble(timeToMove);
            dos.writeInt(cellsCount);
            dos.writeInt(moveToCentre ? 1 : 0);
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                int newMovements = dis.readInt();
                if (newMovements >= 0 && newMovements < Movements.values().length) \{
                    movements = Movements.values()\[newMovements\];
                \}
                double newMovementSpeed = dis.readDouble();
                if (newMovementSpeed >= 0) \{
                    movementSpeed = newMovementSpeed;                    
                \}
                double newTimeToMove = dis.readDouble();
                if (newTimeToMove >= 0) \{
                    timeToMove = newTimeToMove;                    
                \}
                int newCellsCount = dis.readInt();
                if (newCellsCount > 2 && newCellsCount <= MAX_CELLS_COUNT) \{
                    cellsCount = newCellsCount;
                    updateCellsCount();
                \}
                int newMoveToCentre = dis.readInt();
                if (newMoveToCentre == 0 || newMoveToCentre == 1) \{
                    moveToCentre = newMoveToCentre == 1;
                \}
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    // Cell container

    class Cell \{
        final int no;
        final Property moveX;
        final Property moveY;
        List<PVector> polygon;
        
        Cell(int no, Property moveX, Property moveY) \{
            this.no = no;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        PVector centre() \{
            return centresRef.get().get(no);
        \}
        
        List<PVector> polygon() \{
            return polygon;
        \}
    \}
"
    .movements randomly
    .movement-speed 79.9557498044
    .time-to-move 0.20068077223999992
    .cells-count 9
    .width 1920
    .height 1080
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x -1063
    #%graph.y -207
    .period 2
  }
  @ ./clouds core:container {
    #%graph.x -215
    #%graph.y -483
    #%praxis.version 4.1.1
    @ ./warping video:gl:p2d {
      #%graph.x 582
      #%graph.y 170
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    @Inject Property shift;
    
    @P(1) @Type.Number(min=0, max=10, def=2) double gustTime;
    
    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", (millis()+i(shift))/2);
        shader.set(\"resolution\", width, height);
    \}
    
    @T(0) void gust() \{
//        if(!shift.isAnimating()) \{
            shift.to(d(shift)+10000).in(gustTime).easing(Easing.cubicOut);
//        \}
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform vec2 redCell = \{-1.0, -1.0\};

float random (in vec2 _st) \{
    return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) \{
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
\}

#define NUM_OCTAVES 5

float fbm ( in vec2 _st) \{
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5),
                    -sin(0.5), cos(0.50));
    for (int i = 0; i < NUM_OCTAVES; ++i) \{
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    \}
    return v;
\}

void main() \{
    float ktime = pow(time, 0.6); // change power to regulate speed
    vec2 st = gl_FragCoord.xy/resolution.xy*3.;
    st.x += pow(time, 0.4);
//     st += st * abs(sin(time*0.1)*3.0);
    vec3 color = vec3(0.0);

    vec2 q = vec2(0.);
    q.x = fbm( st + .0*ktime);
    q.y = fbm( st + vec2(1.0));

    vec2 r = vec2(0.);
    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*ktime );
    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*ktime);

    float f = fbm(st+r);


    color = mix(vec3(0.101961,0.619608,0.666667),
                vec3(0.666667,0.666667,0.498039),
                clamp((f*f)*4.0,0.0,1.0));

    color = mix(color,
                vec3(0.0,0,0.164706),
                clamp(length(q),0.0,1.0));

    color = mix(color,
                vec3(0.666667,1,1),
                clamp(length(r.x),0.0,1.0));

    gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);
\}
"
    }
    @ ./squares video:gl:p2d {
      #%graph.x 225
      #%graph.y 660
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    double rand;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"rand\", rand);
    \}
    
    @T(1) void shuffle() \{
        rand = random(100);
    \}
    
    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "// Author @patriciogv - 2015
// Title: Mosaic

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform float rand;

float random (vec2 st) \{
    return fract(sin(dot(st.xy*rand,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

void main() \{
    vec2 st = gl_FragCoord.xy/resolution.xy;

    st *= 10.0; // Scale the coordinate system by 10
    vec2 ipos = floor(st);  // get the integer coords
    vec2 fpos = fract(st);  // get the fractional coords

    // Assign a random value based on the integer coord
    vec3 color = vec3(random(ipos));

    // Uncomment to see the subdivided grid
    // color = vec3(fpos,0.0);

    gl_FragColor = vec4(color,1.0);
\}"
    }
    @ ./lines video:gl:p2d {
      #%graph.x 29
      #%graph.y 270
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property timer;
    double angle;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"position\", d(timer));
        shader.set(\"angle\", angle);
    \}
    
    @T(1) void animate() \{
        timer.set(0);
        timer.to(1).in(0.5).linear();
        //timer.animator().whenDone(p -> animate());
        angle = random(-PI, PI);
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
        //animate();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 resolution;
uniform vec2 mouse;
uniform float position;
uniform float angle;

float random (float seed) \{
    return fract(sin(dot(vec2(seed, 1.0),
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

float plot(vec2 st, float pct)\{
  return  smoothstep( pct-0.02, pct, st.y) -
          smoothstep( pct, pct+0.02, st.y);
\}

//  Function from Iñigo Quiles
//  www.iquilezles.org/www/articles/functions/functions.htm
float cubicPulse( float c, float w, float x )\{
    x = abs(x - c);
    if( x>w ) return 0.0;
    x /= w;
    return 1.0 - x*x*(3.0-2.0*x);
\}

mat2 rotate2d(float _angle)\{
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
\}

void main() \{
    if(1 == position) \{
        gl_FragColor = vec4(0.0, 0.0, 0.0,1.0);
        return;
    \}

    vec2 st = gl_FragCoord.xy/max(resolution.x, resolution.y);
    st -= vec2(0.5);
    st *= rotate2d(angle);
    st += vec2(0.5);

    // Smooth interpolation between 0.1 and 0.9
    float y = cubicPulse(0.5,0.2,(st.x+position*1.2-0.5));
    vec3 color = vec3(y);

    float pct = 0; //plot(st,y);
    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

    gl_FragColor = vec4(color,1.0);
\}
"
    }
    @ ./vor-clouds video:gl:p2d {
      #%graph.x 1148
      #%graph.y 110
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 3
      .edge-width 8
      .draw-cells true
      .just-colours false
    }
    @ ./timer-2 core:timing:timer {
      #%graph.x -17
      #%graph.y 48
      .period 2
    }
    @ ./timer-3 core:timing:timer {
      #%graph.x -17
      #%graph.y -55
      .period 2
    }
    @ ./out video:container:out {
      #%graph.x 1330
      #%graph.y 310
    }
    @ ./control core:custom {
      #%graph.x -394
      #%graph.y 500
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.oneByOne;
    final double MOVEMENT_SPEED = 40;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 12;
    final double TRANSITION_TIME = 10;
    
    @Out(209) Output showSquares;
    @Out(210) Output squaresNoWarp;
    @Out(211) Output shuffleEnable;
    @Out(212) Output gustEnable;
    @Out(213) Output strobeEnable;
    @Out(214) Output redStrobeEnable;

    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void justClouds() \{
        showSquares.send(false);
        shuffleEnable.send(false);
        gustEnable.send(false);
        strobeEnable.send(false);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(2)
    void gusts() \{
        showSquares.send(false);
        shuffleEnable.send(false);
        gustEnable.send(true);
        strobeEnable.send(false);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(3)
    void shuffle() \{
        showSquares.send(true);
        shuffleEnable.send(true);
        gustEnable.send(true);
        strobeEnable.send(true);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(4)
    void thunder() \{
        showSquares.send(true);
        shuffleEnable.send(true);
        gustEnable.send(true);
        strobeEnable.send(true);
        squaresNoWarp.send(0);
        redStrobeEnable.send(true);
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x -144
      #%graph.y 835
      .address /video/x-fader.to-clouds
    }
    @ ./properties-in core:property {
      #%graph.x -651
      #%graph.y 716
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./squares-shuffler core:timing:animator {
      #%graph.x -41
      #%graph.y 385
      .code "

    @Inject Property shuffler, recoiler;

    @P(3) @Type.Number(min = 0, max = 60, def = 0)
    double shuffleTime;

    @P(4) @Type.Number(min = 0, max = 60, def = 0)
    double recoilTime;
    
    @Out(1) Output shuffleOut;
    @Out(2) Output gustOut;
    @Out(3) Output strobeOut;
    
    @P(1) @Type.Integer int count;
    
    @P(5) boolean shuffleEnabled;
    @P(6) boolean gustEnabled;
    @P(7) boolean strobeEnabled;

    @T(0) void shuffle() \{
        if (!shuffler.isAnimating() && !recoiler.isAnimating()) \{
            if (shuffleEnabled) \{
                shuffler.set(0).to(count).in(shuffleTime).whenDone(val -> \{
                    val.set(0);
                    recoiler.set(0).to(count).in(recoilTime);
                \});
            \}
            if (gustEnabled) \{
                gustOut.send();
            \}
            if (strobeEnabled) \{
                strobeOut.send();
            \}
        \}
    \}
    
    int lastBlip = 0;

    @Override
    public void update() \{
        if (shuffler.isAnimating()) \{
            int v = i(shuffler.get());
            if(lastBlip != v) \{
                shuffleOut.send();
                lastBlip = v;
            \}
        \}
    \}
"
      .count 40
      .shuffle-time 0.4
      .recoil-time 0.2
    }
    @ ./bottom-right core:custom {
      #%graph.x 1266
      #%graph.y 875
    }
    @ ./top-left core:custom {
      #%graph.x -1039
      #%graph.y -593
    }
    @ ./ping-control core:custom {
      #%graph.x -547
      #%graph.y 20
      .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
      .fft-enabled true
      .tap-enabled true
      .osc-enabled true
    }
    @ ./strobe-0 video:gl:p2d {
      #%graph.x 763
      #%graph.y -350
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.3
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-red video:gl:p2d {
      #%graph.x 561
      #%graph.y -77
      .code "import java.awt.Color;


    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    
    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;
    
    @P(20) boolean enabled;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if(enabled) \{
            if (shader == null) \{
                shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
            \}
            shader(shader);
            shader.set(\"brightness\", d(strobeBrightness));
            shader.set(\"colour\", red, green, blue);
            rect(0, 0, width, height);
            resetShader();
        \}
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .ease 0.4
      .red 243.0
      .blue 29.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./trigger-splitter core:custom {
      #%graph.x 236
      #%graph.y -369
      .code "
    @P(0) @Type.Number(def=0) @ReadOnly Property counter;
    
    @Out(0) Output outEach;
    @Out(1) Output out1Of2;
    @Out(2) Output out2Of2;
    @Out(3) Output out1Of4;
    @Out(4) Output out2Of4;
    @Out(5) Output out3Of4;
    @Out(6) Output out4Of4;
    @Out(7) Output out1Of8;
    @Out(8) Output out2Of8;
    @Out(9) Output out3Of8;
    @Out(10) Output out4Of8;
    @Out(11) Output out5Of8;
    @Out(12) Output out6Of8;
    @Out(13) Output out7Of8;
    @Out(14) Output out8Of8;
    
    @T(0) void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch(count) \{
            case 0: out1Of2.send(); out1Of4.send(); out1Of8.send(); break;
            case 1: out2Of2.send(); out2Of4.send(); out2Of8.send(); break;
            case 2: out1Of2.send(); out3Of4.send(); out3Of8.send(); break;
            case 3: out2Of2.send(); out4Of4.send(); out4Of8.send(); break;
            case 4: out1Of2.send(); out1Of4.send(); out5Of8.send(); break;
            case 5: out2Of2.send(); out2Of4.send(); out6Of8.send(); break;
            case 6: out1Of2.send(); out3Of4.send(); out7Of8.send(); break;
            case 7: out2Of2.send(); out4Of4.send(); out8Of8.send(); break;
        \}
    \}
    
    @T(1) void reset() \{
        counter.set(0);
    \}
"
    }
    @ ./properties-out core:routing:send {
      #%graph.x -140
      #%graph.y 775
      .address /video/voronoi-generator.properties-in
    }
    @ ./in core:container:in {
      #%graph.x 1019
      #%graph.y 528
    }
    @ ./noise-warp video:gl:p3d {
      #%graph.x 590
      #%graph.y 385
      .code "

    @P(1) @Type.Number(min = 0, max = 1, def = 0.1)
    Property amplitude;
    @P(2) @Type.Number(min = 0, max = 1, def = 0.1)
    double speed;
    @P(3) @Type.Number(min = 0, max = 5, def = 2)
    double frequency;
    @P(100)
    Property _time;
    
    @T(0) void warp() \{
        if(!amplitude.isAnimating()) \{
            amplitude.set(1).to(0).in(1).easeIn();
        \}
    \}
    
    void updateUniforms() \{
        if (!_time.isAnimating()) \{
            _time.set(0).to(86400).in(86400);
        \}
        shader.set(\"time\", d(_time));
        shader.set(\"amplitude\", d(amplitude));
        shader.set(\"speed\", speed);
        shader.set(\"frequency\", frequency);
    \}

    
    // BOILERPLATE BELOW
    @In(0)
    PImage in;
    @P(0)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        updateUniforms();
        image(in, 0, 0);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}

"
      .fragment "
varying vec4 vertTexCoord;
uniform sampler2D texture;
uniform float time;
uniform float amplitude;
uniform float speed;
uniform float frequency;

            //
            // Description : Array and textureless GLSL 2D/3D/4D simplex
            // noise functions.
            // Author : Ian McEwan, Ashima Arts.
            // Maintainer : ijm
            // Lastmod : 20110822 (ijm)
            // License : Copyright (C) 2011 Ashima Arts. All rights reserved.
            // Distributed under the MIT License. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x) \{
             return x - floor(x * (1.0 / 289.0)) * 289.0;
            \}

            vec4 mod289(vec4 x) \{
             return x - floor(x * (1.0 / 289.0)) * 289.0;
            \}

            vec4 permute(vec4 x) \{
             return mod289(((x*34.0)+1.0)*x);
            \}

            vec4 taylorInvSqrt(vec4 r)
            \{
                return 1.79284291400159 - 0.85373472095314 * r;
            \}
                                             
            float snoise(vec3 v)
            \{
                const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                
                // First corner
                vec3 i = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                
                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                
                // x0 = x0 - 0.0 + 0.0 * C.xxx;
                // x1 = x0 - i1 + 1.0 * C.xxx;
                // x2 = x0 - i2 + 2.0 * C.xxx;
                // x3 = x0 - 1.0 + 3.0 * C.xxx;
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y
                
                // Permutations
                i = mod289(i);
                vec4 p = permute( permute( permute(
                                                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                
                // Gradients: 7x7 points over a square, mapped onto an octahedron.
                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
                float n_ = 0.142857142857; // 1.0/7.0
                vec3 ns = n_ * D.wyz - D.xzx;
                
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)
                
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)
                
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                
                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                
                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                
                // Mix final noise value
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                             dot(p2,x2), dot(p3,x3) ) );
            \}
            // end of noise functions
                                         
            void main()
            \{
                vec2 texCoords = vertTexCoord.st + vec2(
                    amplitude * (snoise(vec3(frequency * vertTexCoord.st.s, frequency * vertTexCoord.st.t, speed * time))),
                    amplitude * (snoise(vec3(frequency * vertTexCoord.st.s + 17.0, frequency * vertTexCoord.st.t, speed * time)))
                );
                vec2 pos = 0.5 - vertTexCoord.st;  
                gl_FragColor = texture2D(texture, texCoords); 
            \}"
      .amplitude 0.0
    }
    @ ./xfader video:xfader {
      #%graph.x 836
      #%graph.y 500
      .mix 1.0
    }
    @ ./squares-fader video:xfader {
      #%graph.x 400
      #%graph.y 675
      .code "

    @In(1) PImage in;
    
    @P(1) @OnChange(\"fadeInOut\")
    boolean enabled;
    
    @P(2) @Type.Number(min=0, max=5, def=2)
    double fadeTime;
    
    @Inject Property mix;
    
    void fadeInOut() \{
        mix.set(enabled ? 0 : 1).to(enabled ? 1 : 0).in(fadeTime).easeIn();
    \}
    
    @Override
    public void draw() \{
        if (d(mix) > 0.999) \{
            copy(in);
            release(in);
        \} else if (d(mix) > 0.001) \{
            blendMode(ADD, d(mix));
            image(in, 0, 0);
        \}
    \}
    
"
    }
    ~ ./warping!out ./vor-clouds!in-0
    ~ ./lines!out ./vor-clouds!in-edges
    ~ ./warping!out ./vor-clouds!in-1
    ~ ./warping!out ./vor-clouds!in-2
    ~ ./vor-clouds!out ./out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./warping!out ./vor-clouds!in-edges
    ~ ./strobe-0!out ./vor-clouds!in-0
    ~ ./strobe-0!out ./vor-clouds!in-1
    ~ ./strobe-0!out ./vor-clouds!in-2
    ~ ./squares-shuffler!shuffle-out ./squares!shuffle
    ~ ./trigger-splitter!out-2-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-3-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-4-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-1-of-4 ./strobe-red!strobe
    ~ ./strobe-red!out ./vor-clouds!in-0
    ~ ./strobe-red!out ./vor-clouds!in-1
    ~ ./strobe-red!out ./vor-clouds!in-2
    ~ ./ping-control!ping-2-cyan ./lines!animate
    ~ ./ping-control!ping-1-yellow ./squares-shuffler!shuffle
    ~ ./control!properties-out ./properties-out!in
    ~ ./in!out ./vor-clouds!voronoi-in
    ~ ./trigger-splitter!out-1-of-4 ./noise-warp!warp
    ~ ./control!gust-enable ./squares-shuffler!gust-enabled
    ~ ./squares-shuffler!gust-out ./warping!gust
    ~ ./control!strobe-enable ./squares-shuffler!strobe-enabled
    ~ ./squares-shuffler!strobe-out ./trigger-splitter!trigger
    ~ ./control!shuffle-enable ./squares-shuffler!shuffle-enabled
    ~ ./noise-warp!out ./xfader!in-1
    ~ ./xfader!out ./vor-clouds!in-2
    ~ ./control!squares-no-warp ./xfader!mix
    ~ ./control!red-strobe-enable ./strobe-red!enabled
    ~ ./squares-fader!out ./xfader!in-2
    ~ ./squares-fader!out ./noise-warp!in
    ~ ./squares!out ./squares-fader!in
    ~ ./control!show-squares ./squares-fader!enabled
  }
  @ ./bw core:container {
    #%graph.x -215
    #%graph.y -581
    #%praxis.version 4.1.1
    @ ./vor-bw video:gl:p2d {
      #%graph.x 1185
      #%graph.y 42
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 5
      .edge-width 1
      .draw-cells true
      .just-colours false
    }
    @ ./out video:container:out {
      #%graph.x 1438
      #%graph.y 242
    }
    @ ./in core:container:in {
      #%graph.x 958
      #%graph.y 442
    }
    @ ./properties-send core:routing:send {
      #%graph.x 420
      #%graph.y 760
      .address /video/voronoi-generator.properties-in
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 420
      #%graph.y 810
      .address /video/x-fader.to-bw
    }
    @ ./control core:custom {
      #%graph.x 69
      #%graph.y 167
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    @Out(32) Output blackCells0;
    @Out(33) Output whiteCells0;
    @Out(34) Output blackCells1;
    @Out(35) Output whiteCells1;
    @Out(40) Output blackEdges;
    @Out(41) Output whiteEdges;
    
    @Out(50) Output strobeMain;
    @Out(51) Output strobeHeavy;
    @Out(52) Output strobeHeavyNow;
    
    @Inject Property timer;
    
    void defaults() \{
        targetMovements = Movements.randomly;
        targetMovementSpeed = 10;
        targetTimeToMove = 0.4;
        targetMoveToCentre = 0;
        targetCellsCount = 40;
        transitionTime = 6;
    \}

    @T(30) void fastEdges() \{
        defaults();
        startUpdating();
        
        whiteEdges.send();
        blackCells0.send();
        blackCells1.send();
        strobeMain.send(false);
        strobeHeavy.send(false);
        timer.set(0).to(1).in(1).whenDone(t -> \{
            strobeMain.send(true);
        \});
    \}

    @T(31) void whiteCells() \{
        defaults();
        startUpdating();

        blackCells0.send();
        strobeMain.send(true);
        strobeHeavy.send(true);
        timer.set(0).to(1).in(3).whenDone(t -> \{
            strobeHeavy.send(false);
            whiteCells1.send();
            blackEdges.send();
        \});
    \}

    @T(32) void strobeCells() \{
        defaults();
        targetCellsCount = 20;
        targetMovementSpeed = 30;
        startUpdating();
        
        blackEdges.send();
        blackCells0.send();
        timer.set(0).to(1).in(1).whenDone(t2 -> blackCells1.send());
        strobeMain.send(true);
        strobeHeavy.send(false);
    \}

    @T(33) void fluidEdges() \{
        defaults();
        targetMovementSpeed = 30;
        targetTimeToMove = 4;
        targetMovements = Movements.all;
        startUpdating();

        blackEdges.send();
        blackCells0.send();
        blackCells1.send();
        strobeMain.send(true);
        strobeHeavy.send(true);
        strobeHeavyNow.send();
        timer.set(0).to(1).in(2).whenDone(t2 -> \{
            strobeHeavy.send(true);
            t2.set(0).to(1).in(0.5).whenDone(t3 -> \{
                whiteEdges.send();
                strobeHeavy.send(false);
            \});
        \});
    \}
    
    
////////////////////////////////////////////////////////
//// Common code below (v.2.0) 
    @P(0)
    @OnChange(\"startUpdating\")
    Movements targetMovements = Movements.randomly;
    @P(1) @Type.Number(min=0, max=100, def=10)
    @OnChange(\"startUpdating\")
    double targetMovementSpeed;
    @P(2) @Type.Number(min=0, max=10, def=0.4, skew=3)
    @OnChange(\"startUpdating\")
    double targetTimeToMove = 0.4;
    @P(3) @Type.Integer(min=0, max=1, def=0)
    @OnChange(\"startUpdating\")
    int targetMoveToCentre;
    @P(4) @Type.Integer(min=0, max=80, def=40)
    @OnChange(\"startUpdating\")
    int targetCellsCount;
    @P(5) @Type.Number(min=0, max=20, def=8)
    double transitionTime = 10;
    
    Movements currentMovements;
    double currentMovementSpeed;
    double currentTimeToMove;
    int currentCcellsCount;
    int currentMoveToCentre;

    @Inject
    Movements newMovements;
    @Inject
    Property newMovementSpeed;
    @Inject
    Property newTimeToMove;
    @Inject
    Property newCellsCount;
    @Inject
    Property newMoveToCentre;
    
    @P(50) @ReadOnly
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = targetMovements;
        newMovementSpeed.set(targetMovementSpeed);
        newTimeToMove.set(targetTimeToMove);
        newMoveToCentre.set(targetMoveToCentre);
        newCellsCount.set(targetCellsCount);
        transition.set(0);
    \}
    
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < transitionTime/2) \{
                newMovements = targetMovements;
                newMoveToCentre.set(targetMoveToCentre);
            \}
            send();
        \}
    \}
    
    void startUpdating() \{
        xFade.send();
        transition.set(0).to(100).in(transitionTime);
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
      .target-movements randomly
      .target-movement-speed 30.0
      .target-cells-count 20
      .transition-time 6.0
    }
    @ ./properties-in core:property {
      #%graph.x -242
      #%graph.y 367
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./edges video:gl:p2d {
      #%graph.x 715
      #%graph.y 317
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
    }
    @ ./cells-0 video:gl:p2d {
      #%graph.x 713
      #%graph.y 20
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
    }
    @ ./cells-1 video:gl:p2d {
      #%graph.x 713
      #%graph.y 167
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
    }
    @ ./bottom-right core:custom {
      #%graph.x 1659
      #%graph.y 1030
    }
    @ ./top-left core:custom {
      #%graph.x -872
      #%graph.y -730
    }
    @ ./strobes core:container {
      #%graph.x 638
      #%graph.y -484
      #%praxis.version 4.1.1
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-4 video:gl:p2d {
        #%graph.x 652
        #%graph.y 197
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-4 video:container:out {
        #%graph.x 1301
        #%graph.y 197
      }
      @ ./strobe-5 video:gl:p2d {
        #%graph.x 792
        #%graph.y 247
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-5 video:container:out {
        #%graph.x 1301
        #%graph.y 247
      }
      @ ./strobe-6 video:gl:p2d {
        #%graph.x 932
        #%graph.y 297
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease .2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-6 video:container:out {
        #%graph.x 1301
        #%graph.y 297
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-4 core:container:in {
        #%graph.x -134
        #%graph.y 197
      }
      @ ./in-5 core:container:in {
        #%graph.x -134
        #%graph.y 247
      }
      @ ./in-6 core:container:in {
        #%graph.x -134
        #%graph.y 297
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-4!out ./out-4!in
      ~ ./strobe-5!out ./out-5!in
      ~ ./strobe-6!out ./out-6!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-4!out ./strobe-4!strobe
      ~ ./in-5!out ./strobe-5!strobe
      ~ ./in-6!out ./strobe-6!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x 420
      #%graph.y -509
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(4) Output out4;
    @Out(5) Output out5;
    @Out(6) Output out6;
    @Out(7) Output out7;
    @Inject Property four;
    @P(10) boolean enabled;
    @P(11) boolean heavyEnabled;
    
    void send(Output out) \{
        if(enabled) \{
            out.send();
        \}
    \}
    
    @T(0) public void strobe0() \{ send(out0); \}
    @T(1) public void strobe1() \{ send(out1); \}
    @T(2) public void strobe2() \{ send(out2); \}
    @T(3) public void strobe3() \{ send(out3); \}
    @T(4) public void strobe4() \{ send(out4); \}
    @T(5) public void strobe5() \{ send(out5); \}
    @T(6) public void strobe6() \{ send(out6); \}
    @T(7) public void strobe7() \{ send(out7); \}
    @T(8) public void firstFour() \{
        if(heavyEnabled) \{
            final double delay = 0.05;
            four.set(0).to(1).in(delay).whenDone(one -> \{
                send(out0);
                one.set(0).to(1).in(delay).whenDone(two -> \{
                    send(out1);
                    two.set(0).to(1).in(delay).whenDone(three -> \{
                        send(out2);
                        three.set(0).to(1).in(delay).whenDone(four -> \{
                            send(out3);
                        \});
                    \});
                \});
            \});
        \}
    \}
    
"
      .enabled true
    }
    @ ./trigger-splitter core:custom {
      #%graph.x -124
      #%graph.y -540
      .code "
    @P(0) @Type.Number(def=0) @ReadOnly Property counter;
    
    @Out(0) Output outEach;
    @Out(1) Output out1Of2;
    @Out(2) Output out2Of2;
    @Out(3) Output out1Of4;
    @Out(4) Output out2Of4;
    @Out(5) Output out3Of4;
    @Out(6) Output out4Of4;
    @Out(7) Output out1Of8;
    @Out(8) Output out2Of8;
    @Out(9) Output out3Of8;
    @Out(10) Output out4Of8;
    @Out(11) Output out5Of8;
    @Out(12) Output out6Of8;
    @Out(13) Output out7Of8;
    @Out(14) Output out8Of8;
    
    @T(0) void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch(count) \{
            case 0: out1Of2.send(); out1Of4.send(); out1Of8.send(); break;
            case 1: out2Of2.send(); out2Of4.send(); out2Of8.send(); break;
            case 2: out1Of2.send(); out3Of4.send(); out3Of8.send(); break;
            case 3: out2Of2.send(); out4Of4.send(); out4Of8.send(); break;
            case 4: out1Of2.send(); out1Of4.send(); out5Of8.send(); break;
            case 5: out2Of2.send(); out2Of4.send(); out6Of8.send(); break;
            case 6: out1Of2.send(); out3Of4.send(); out7Of8.send(); break;
            case 7: out2Of2.send(); out4Of4.send(); out8Of8.send(); break;
        \}
    \}
    
    @T(1) void reset() \{
        counter.set(0);
    \}
"
    }
    @ ./move-cell-timer core:timing:timer {
      #%graph.x -648
      #%graph.y -455
    }
    @ ./fft-red core:timing:timer {
      #%graph.x -572
      #%graph.y -550
    }
    @ ./ping-control core:custom {
      #%graph.x -389
      #%graph.y -550
      .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
      .fft-enabled true
      .tap-enabled true
      .osc-enabled true
    }
    @ ./osc-receiver core:custom {
      #%graph.x -389
      #%graph.y -646
      .code "

    @Out(1) Output oscSignal;

    @T(1) void signal() \{
//        log(WARNING, \"YO\");
        oscSignal.send();
    \}

"
    }
    ~ ./vor-bw!out ./out!in
    ~ ./in!out ./vor-bw!voronoi-in
    ~ ./control!properties-out ./properties-send!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./edges!out ./vor-bw!in-edges
    ~ ./control!white-edges ./edges!white
    ~ ./cells-0!out ./vor-bw!in-0
    ~ ./cells-0!out ./vor-bw!in-1
    ~ ./cells-0!out ./vor-bw!in-2
    ~ ./cells-0!out ./vor-bw!in-3
    ~ ./cells-1!out ./vor-bw!in-4
    ~ ./control!black-edges ./edges!black
    ~ ./control!white-cells-1 ./cells-1!white
    ~ ./control!black-cells-1 ./cells-1!black
    ~ ./control!white-cells-0 ./cells-0!white
    ~ ./control!black-cells-0 ./cells-0!black
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./strobe-control!out-4 ./strobes!in-4
    ~ ./strobe-control!out-5 ./strobes!in-5
    ~ ./strobe-control!out-6 ./strobes!in-6
    ~ ./strobe-control!out-7 ./strobes!in-7
    ~ ./strobes!out-0 ./vor-bw!in-0
    ~ ./strobes!out-1 ./vor-bw!in-1
    ~ ./strobes!out-7 ./vor-bw!in-edges
    ~ ./strobes!out-2 ./vor-bw!in-2
    ~ ./strobes!out-3 ./vor-bw!in-3
    ~ ./control!strobe-main ./strobe-control!enabled
    ~ ./control!strobe-heavy ./strobe-control!heavy-enabled
    ~ ./ping-control!ping-1-yellow ./strobe-control!strobe-1
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-2
    ~ ./ping-control!ping-2-cyan ./strobe-control!first-four
    ~ ./control!strobe-heavy-now ./strobe-control!first-four
    ~ ./ping-control!ping-0-red ./trigger-splitter!trigger
    ~ ./trigger-splitter!out-1-of-2 ./strobe-control!strobe-0
  }
  @ ./top-left core:custom {
    #%graph.x -1094
    #%graph.y -878
  }
  @ ./right-bottom core:custom {
    #%graph.x 856
    #%graph.y 207
  }
  @ ./bw-control core:routing:send {
    #%graph.x -430
    #%graph.y -104
    .address /video/bw/properties-in.in
  }
  @ ./clouds-control core:routing:send {
    #%graph.x -430
    #%graph.y -54
    .address /video/clouds/properties-in.in
  }
  @ ./ping-control core:custom {
    #%graph.x -1063
    #%graph.y -721
    .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
    .fft-enabled true
    .tap-enabled true
    .osc-enabled true
  }
  @ ./colours core:container {
    #%graph.x -217
    #%graph.y -396
    #%praxis.version 4.1.1
    @ ./vor-colours video:gl:p2d {
      #%graph.x 1488
      #%graph.y 199
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 8
      .draw-cells true
      .just-colours false
    }
    @ ./control core:custom {
      #%graph.x 184
      #%graph.y 470
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 28;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 1;
    final int CELLS_COUNT = 36;
    final double TRANSITION_TIME = 8;
    
    @Out(10)
    Output redAndBlack;
    @Out(11)
    Output grey;
    @Out(12)
    Output colours;
    @Out(15)
    Output trueStrobeFalseShuffle;
    
    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void grey() \{
        activate();
        grey.send();
        trueStrobeFalseShuffle.send(true);
    \}
    
    @T(2)
    void colours() \{
        activate();
        colours.send();
        trueStrobeFalseShuffle.send(false);
    \}
    
    @T(3)
    void redAndBlack() \{
        activate();
        redAndBlack.send();
        trueStrobeFalseShuffle.send(true);
    \}
    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @Out(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @Out(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 413
      #%graph.y 820
      .address /video/x-fader.to-colours
    }
    @ ./properties-in core:property {
      #%graph.x -34
      #%graph.y 595
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./ping-control core:custom {
      #%graph.x 14
      #%graph.y 6
      .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
      .fft-enabled true
      .tap-enabled true
      .osc-enabled true
    }
    @ ./properties-out core:routing:send {
      #%graph.x 471
      #%graph.y 731
      .address /video/voronoi-generator.properties-in
    }
    @ ./strobes core:container {
      #%graph.x 1273
      #%graph.y 233
      #%praxis.version 4.1.1
      #%graph.minimized true
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x 734
      #%graph.y 6
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(7) Output edges7;
    
    @P(1) boolean enabledCells;
    @P(2) boolean enabledEdges;
    
    @T(0) public void strobe0() \{ 
        if(enabledCells) \{
            out0.send();
        \}
    \}
    
    @T(1)
    public void strobe1() \{
        if(enabledCells) \{
            out1.send();
        \}
    \}

    @T(2)
    public void strobe2() \{
        if(enabledCells) \{
            out2.send();
        \}
    \}

    @T(3)
    public void strobe3() \{
        if(enabledCells) \{
            out3.send();
        \}
    \}

    @T(7)
    public void strobeEdges() \{
        if(enabledEdges) \{
            edges7.send();
        \}
    \}
    
"
      .enabled-cells true
      .enabled-edges true
    }
    @ ./out video:container:out {
      #%graph.x 1697
      #%graph.y 399
    }
    @ ./in core:container:in {
      #%graph.x 1355
      #%graph.y 599
    }
    @ ./todo core:custom {
      #%graph.x 1389
      #%graph.y 1154
      #%graph.comment Several palettes:\n2-3 colours\n1 b/w\n1 grayscale (with one stray colour running around)\n\nTransition between palettes - mix them\n\n- coloured strobes\n- combine strobes and colours\n- use more advanced shaders on colours/strobes\n\nExperiment with movements:\n- circular\n- boids\n- phalanx
    }
    @ ./strobe-vs-shuffle core:custom {
      #%graph.x 438
      #%graph.y 79
      .code "

    @P(0) boolean trueForStrobe;
    
    @Out(0) Output strobe0;
    @Out(1) Output strobe1;
    @Out(2) Output strobe2;
    @Out(3) Output shuffle;
    
    @T(0)
    void ping0() \{
        if(trueForStrobe) \{
            strobe0.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
    @T(1)
    void ping1() \{
        if(trueForStrobe) \{
            strobe1.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
    @T(2)
    void ping2() \{
        if(trueForStrobe) \{
            strobe2.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
"
    }
    @ ./colour-control core:variable {
      #%graph.x 949
      #%graph.y 320
      .code "

    final int N = 8;
    final String SWEET\[\] = \{\"ff6530\", \"fbd06b\", \"d84248\", \"883e86\", \"658395\", \"769f85\", \"2f8cb6\", \"000000\"\};
    final String GREY\[\] = \{\"ababab\", \"e0e0e0\", \"f2f2f2\", \"b6b6b6\", \"9f9f9f\", \"4d4d4d\", \"393939\", \"000000\"\};
    final String CGA\[\] = \{\"555555\", \"5555ff\", \"55ff55\", \"55ffff\", \"ff5555\", \"ff55ff\", \"ffffff\", \"000000\"\};
    final String BW\[\] = \{\"ffffff\", \"ffffff\", \"ffffff\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\"\};
    final String RED_BW\[\] = \{\"ff0000\", \"ffffff\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\"\};

    List<String> current;
    List<String> target;

    @Inject String rgb0;
    @Inject String rgb1;
    @Inject String rgb2;
    @Inject String rgb3;
    @Inject String rgb4;
    @Inject String rgb5;
    @Inject String rgb6;
    @Inject String rgbEdge;

    @P(10)
    @Type.Number
    double transitionTime;

    @P(11)
    @Type.Number
    double transitionStep;
    
    @Inject
    Property r0, r1, r2, r3, r4, r5, r6, rEdge;
    @Inject
    Property g0, g1, g2, g3, g4, g5, g6, gEdge;
    @Inject
    Property b0, b1, b2, b3, b4, b5, b6, bEdge;
    @Inject
    Property t0, t1, t2, t3, t4, t5, t6, tEdge;

    @AuxOut(0)
    Output out0;
    @AuxOut(1)
    Output out1;
    @AuxOut(2)
    Output out2;
    @AuxOut(3)
    Output out3;
    @AuxOut(4)
    Output out4;
    @AuxOut(5)
    Output out5;
    @AuxOut(6)
    Output out6;
    @AuxOut(7)
    Output out7;
    
    @Inject
    Property transitionTimer;
    
    @P(50)
    boolean shuffleEnabled;

    @Override
    public void starting() \{
// causing startup  errors        
//        rgbToInts();
    \}

    @Override
    public void update() \{
        intToRgbAndSend();
    \}

    @T(0)
    void sweet() \{
        transitionToPalette(SWEET);
    \}

    @T(1)
    void grey() \{
        transitionToPalette(GREY);
    \}

    @T(3)
    void bw() \{
        transitionToPalette(BW);
    \}

    @T(4)
    void redBw() \{
        transitionToPalette(RED_BW);
    \}

//    @T(5)
//    void cga() \{
//        transitionToPalette(CGA);
//    \}
    
    
    @T(10)
    void shuffle() \{
        if(shuffleEnabled) \{
            // skipping rgbEdge
            List<String> paletteList = new ArrayList<>(Arrays.asList(rgbs()).subList(0, N-1));
            Collections.shuffle(paletteList); 
            paletteList.add(rgbs()\[N-1\]);
            transitionToPalette(paletteList.toArray(new String\[0\]), true);
        \}
    \}
    
    @T(11)
    void invert() \{
        String\[\] palette = 
                new ArrayList<>(Arrays.asList(rgbs())).stream()
                .map(this::rgbToInts)
                .map(i -> new int\[\] \{~i\[0\] & 0xff, ~i\[1\] & 0xff, ~i\[2\] & 0xff\})
                .map(this::intsToRgbString)
                .collect(Collectors.toList())
                .toArray(new String\[0\]);
        transitionToPalette(palette);
    \}
    
    @T(20)
    void whiteEdges() \{
        String\[\] palette = Arrays.copyOf(rgbs(), N);
        palette\[N-1\] = \"ffffff\";
        transitionToPalette(palette);
    \}
    
    @T(21)
    void blackEdges() \{
        String\[\] palette = Arrays.copyOf(rgbs(), N);
        palette\[N-1\] = \"000000\";
        transitionToPalette(palette);
    \}
    
    void intToRgbAndSend() \{
        for (int c = 0; c < N; ++c) \{
            int\[\] ints = new int\[\]\{i(reds()\[c\]), i(greens()\[c\]), i(blues()\[c\])\};
            setRgb(c, intsToRgbString(ints));
            outs()\[c\].send(intsToRgbInt(ints));
        \}
    \}
    
    void rgbToInts() \{
        for (int c = 0; c < N; ++c) \{
            int\[\] rgbi = rgbToInts(rgbs()\[c\]);
            reds()\[c\].set(rgbi\[0\]);
            greens()\[c\].set(rgbi\[1\]);
            blues()\[c\].set(rgbi\[2\]);
            outs()\[c\].send(intsToRgbInt(rgbi));
        \}
    \}

    void transitionToPalette(String\[\] palette) \{
        shuffleEnabled = false;
        double safeDelay = (transitionStep * (N - 1)) + transitionTime + 0.1;
        transitionTimer.set(0).to(1).in(safeDelay).whenDone(t -> \{
            transitionToPalette(palette, false);
            t.to(1).in(safeDelay).whenDone(t1 -> shuffleEnabled = true);
        \});
    \}
    
    void transitionToPalette(String\[\] palette, boolean shuffling) \{
        if(!reds()\[0\].isAnimating() && !steps()\[0\].isAnimating()) \{
            for (int c = 0; c < N; ++c) \{ 
                int i = c;
                int rgb = Integer.parseInt(palette\[i\], 16);
                int r = rgb >> 16;
                int g = (rgb & 0x00ff00) >> 8;
                int b = rgb & 0x0000ff;
                double step = transitionStep*(N-i);
                steps()\[i\].set(0).to(1).in(step).whenDone(t -> \{
                    reds()\[i\].to(r).in(transitionTime);
                    greens()\[i\].to(g).in(transitionTime);
                    blues()\[i\].to(b).in(transitionTime);
                \});
            \}
        \};
    \}
    
    String\[\] toGreyScale(String\[\] palette) \{
        String\[\] greyPalette = new String\[N\];
        for(int i=0; i<N; ++i) \{
            int\[\] rgbi = rgbToInts(palette\[i\]);
            int grey = (rgbi\[0\] + rgbi\[1\] + rgbi\[2\])/3;
            greyPalette\[i\] = intsToRgbString(new int\[\] \{grey, grey, grey\});
        \}
        return greyPalette;
    \}

    void setRgb(int i, String rgb) \{
        if (0 == i) \{
            rgb0 = rgb;
        \} else if (1 == i) \{
            rgb1 = rgb;
        \} else if (2 == i) \{
            rgb2 = rgb;
        \} else if (3 == i) \{
            rgb3 = rgb;
        \} else if (4 == i) \{
            rgb4 = rgb;
        \} else if (5 == i) \{
            rgb5 = rgb;
        \} else if (6 == i) \{
            rgb6 = rgb;
        \} else if (7 == i) \{
            rgbEdge = rgb;
        \}
    \}

    int\[\] rgbToInts(String rgb) \{
        int i = Integer.parseInt(rgb, 16);
        return new int\[\]\{i >> 16, (i & 0x00ff00) >> 8, i & 0x0000ff\};
    \}

    String intsToRgbString(int rgb\[\]) \{
        return String.format(\"%02X%02X%02X\", rgb\[0\], rgb\[1\], rgb\[2\]);
    \}

    int intsToRgbInt(int rgb\[\]) \{
        return (rgb\[0\] << 16) + (rgb\[1\] << 8) + rgb\[2\];
    \}

    String\[\] rgbs() \{
        return new String\[\]\{rgb0, rgb1, rgb2, rgb3, rgb4, rgb5, rgb6, rgbEdge\};
    \}

    Property\[\] reds() \{
        return new Property\[\]\{r0, r1, r2, r3, r4, r5, r6, rEdge\};
    \}

    Property\[\] greens() \{
        return new Property\[\]\{g0, g1, g2, g3, g4, g5, g6, gEdge\};
    \}

    Property\[\] blues() \{
        return new Property\[\]\{b0, b1, b2, b3, b4, b5, b6, bEdge\};
    \}

    Property\[\] steps() \{
        return new Property\[\]\{t0, t1, t2, t3, t4, t5, t6, tEdge\};
    \}

    Output\[\] outs() \{
        return new Output\[\]\{out0, out1, out2, out3, out4, out5, out6, out7\};
    \}
"
      .transition-time 0.1
      .transition-step 0.1
      .shuffle-enabled true
    }
    @ ./colours core:container {
      #%graph.x 1273
      #%graph.y 370
      #%praxis.version 4.1.1
      #%graph.minimized true
      @ ./colour-1 video:gl:p2d {
        #%graph.x 159
        #%graph.y 20
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -39632
        .hex-rgb FF6530
        .red 255.0
        .green 101.0
        .blue 48.0
        .hue 0.04267311096191406
        .saturation 0.8117647171020508
        .brightness 1.0
      }
      @ ./colour-3 video:gl:p2d {
        #%graph.x 435
        #%graph.y 120
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -13661002
        .hex-rgb 2F8CB6
        .red 47.0
        .green 140.0
        .blue 182.0
        .hue 0.5518518090248108
        .saturation 0.7417582273483276
        .brightness 0.7137255072593689
      }
      @ ./colour-4 video:gl:p2d {
        #%graph.x 573
        #%graph.y 170
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -6144142
        .hex-rgb A23F72
        .red 162.0
        .green 63.0
        .blue 114.0
        .hue 0.9141414165496826
        .saturation 0.6111111044883728
        .brightness 0.6352941393852234
      }
      @ ./colour-5 video:gl:p2d {
        #%graph.x 711
        #%graph.y 220
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -39632
        .hex-rgb FF6530
        .red 255.0
        .green 101.0
        .blue 48.0
        .hue 0.04267311096191406
        .saturation 0.8117647171020508
        .brightness 1.0
      }
      @ ./colour-6 video:gl:p2d {
        #%graph.x 849
        #%graph.y 270
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -9003131
        .hex-rgb 769F85
        .red 118.0
        .green 159.0
        .blue 133.0
        .hue 0.3943089544773102
        .saturation 0.2578616440296173
        .brightness 0.6235294342041016
      }
      @ ./colour-2 video:gl:p2d {
        #%graph.x 297
        #%graph.y 70
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -9003131
        .hex-rgb 769F85
        .red 118.0
        .green 159.0
        .blue 133.0
        .hue 0.3943089544773102
        .saturation 0.2578616440296173
        .brightness 0.6235294342041016
      }
      @ ./colour-0 video:gl:p2d {
        #%graph.x 21
        #%graph.y -30
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -10124395
        .hex-rgb 658395
        .red 101.0
        .green 131.0
        .blue 107.0
        .hue 0.11689814925193787
        .saturation 0.5737051963806152
        .brightness 0.9843137264251709
      }
      @ ./colour-7 video:gl:p2d {
        #%graph.x 987
        #%graph.y 320
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./out-0 video:container:out {
        #%graph.x 1180
        #%graph.y -30
      }
      @ ./out-1 video:container:out {
        #%graph.x 1180
        #%graph.y 20
      }
      @ ./out-2 video:container:out {
        #%graph.x 1180
        #%graph.y 70
      }
      @ ./out-3 video:container:out {
        #%graph.x 1180
        #%graph.y 120
      }
      @ ./out-4 video:container:out {
        #%graph.x 1180
        #%graph.y 170
      }
      @ ./out-5 video:container:out {
        #%graph.x 1180
        #%graph.y 220
      }
      @ ./out-6 video:container:out {
        #%graph.x 1180
        #%graph.y 270
      }
      @ ./out-7 video:container:out {
        #%graph.x 1180
        #%graph.y 320
      }
      @ ./in-0 core:container:in {
        #%graph.x -228
        #%graph.y -5
      }
      @ ./in-1 core:container:in {
        #%graph.x -228
        #%graph.y 45
      }
      @ ./in-2 core:container:in {
        #%graph.x -228
        #%graph.y 95
      }
      @ ./in-3 core:container:in {
        #%graph.x -228
        #%graph.y 145
      }
      @ ./in-4 core:container:in {
        #%graph.x -228
        #%graph.y 195
      }
      @ ./in-5 core:container:in {
        #%graph.x -228
        #%graph.y 245
      }
      @ ./in-6 core:container:in {
        #%graph.x -228
        #%graph.y 295
      }
      @ ./in-7 core:container:in {
        #%graph.x -228
        #%graph.y 345
      }
      ~ ./colour-0!out ./out-0!in
      ~ ./colour-1!out ./out-1!in
      ~ ./colour-2!out ./out-2!in
      ~ ./colour-3!out ./out-3!in
      ~ ./colour-4!out ./out-4!in
      ~ ./colour-5!out ./out-5!in
      ~ ./colour-6!out ./out-6!in
      ~ ./colour-7!out ./out-7!in
      ~ ./in-1!out ./colour-1!int-rgb
      ~ ./in-2!out ./colour-2!int-rgb
      ~ ./in-3!out ./colour-3!int-rgb
      ~ ./in-4!out ./colour-4!int-rgb
      ~ ./in-5!out ./colour-5!int-rgb
      ~ ./in-6!out ./colour-6!int-rgb
      ~ ./in-7!out ./colour-7!int-rgb
      ~ ./in-0!out ./colour-0!int-rgb
    }
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./control!properties-out ./properties-out!in
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./in!out ./vor-colours!voronoi-in
    ~ ./vor-colours!out ./out!in
    ~ ./strobes!out-7 ./vor-colours!in-edges
    ~ ./strobes!out-1 ./vor-colours!in-6
    ~ ./strobes!out-0 ./vor-colours!in-5
    ~ ./strobe-control!edges-7 ./strobes!in-7
    ~ ./strobes!out-1 ./vor-colours!in-4
    ~ ./ping-control!ping-1-yellow ./strobe-vs-shuffle!ping-1
    ~ ./strobe-vs-shuffle!strobe-1 ./strobe-control!strobe-1
    ~ ./strobe-vs-shuffle!strobe-0 ./strobe-control!strobe-0
    ~ ./control!true-strobe-false-shuffle ./strobe-vs-shuffle!true-for-strobe
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-edges
    ~ ./control!grey ./colour-control!grey
    ~ ./control!colours ./colour-control!sweet
    ~ ./control!red-and-black ./colour-control!red-bw
    ~ ./strobe-vs-shuffle!shuffle ./colour-control!shuffle
    ~ ./colour-control!out-0 ./colours!in-0
    ~ ./colour-control!out-1 ./colours!in-1
    ~ ./colour-control!out-2 ./colours!in-2
    ~ ./colour-control!out-3 ./colours!in-3
    ~ ./colour-control!out-4 ./colours!in-4
    ~ ./colour-control!out-5 ./colours!in-5
    ~ ./colour-control!out-6 ./colours!in-6
    ~ ./colour-control!out-7 ./colours!in-7
    ~ ./colours!out-0 ./vor-colours!in-0
    ~ ./colours!out-1 ./vor-colours!in-1
    ~ ./colours!out-2 ./vor-colours!in-2
    ~ ./colours!out-3 ./vor-colours!in-3
    ~ ./colours!out-4 ./vor-colours!in-4
    ~ ./colours!out-5 ./vor-colours!in-5
    ~ ./colours!out-6 ./vor-colours!in-6
    ~ ./colours!out-7 ./vor-colours!in-edges
  }
  @ ./colours-control core:routing:send {
    #%graph.x -430
    #%graph.y -4
    .address /video/colours/properties-in.in
  }
  @ ./start core:start-trigger {
    #%graph.x -948
    #%graph.y -298
  }
  @ ./videos core:container {
    #%graph.x -214
    #%graph.y -298
    #%praxis.version 4.1.1
    @ ./vor-colours video:gl:p2d {
      #%graph.x 1069
      #%graph.y 193
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 0.0
      .draw-cells true
      .just-colours false
    }
    @ ./control core:custom {
      #%graph.x 265
      #%graph.y 395
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 80;
    final double TIME_TO_MOVE = .2;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 9;
    final double TRANSITION_TIME = 10;
    
    @Out(10) Output videoStart;
    
    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(0)
    void buildings() \{
        activate();
        videoStart.send();
    \}
    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @Out(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @Out(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 445
      #%graph.y 694
      .address /video/x-fader.to-videos
    }
    @ ./properties-in core:property {
      #%graph.x 48
      #%graph.y 436
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./ping-control core:custom {
      #%graph.x 8
      #%graph.y 14
      .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
      .fft-enabled true
      .tap-enabled true
      .osc-enabled true
    }
    @ ./properties-out core:routing:send {
      #%graph.x 445
      #%graph.y 622
      .address /video/voronoi-generator.properties-in
    }
    @ ./strobes core:container {
      #%graph.x 568
      #%graph.y 37
      #%praxis.version 4.1.1
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x 240
      #%graph.y 37
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(7) Output edges7;
    
    @P(1) boolean enabledCells;
    @P(2) boolean enabledEdges;
    
    @T(0) public void strobe0() \{ 
        if(enabledCells) \{
            out0.send();
        \}
    \}
    
    @T(1)
    public void strobe1() \{
        if(enabledCells) \{
            out1.send();
        \}
    \}

    @T(2)
    public void strobe2() \{
        if(enabledCells) \{
            out2.send();
        \}
    \}

    @T(3)
    public void strobe3() \{
        if(enabledCells) \{
            out3.send();
        \}
    \}

    @T(7)
    public void strobeEdges() \{
        if(enabledEdges) \{
            edges7.send();
        \}
    \}
    
"
      .enabled-cells true
      .enabled-edges true
    }
    @ ./out video:container:out {
      #%graph.x 1278
      #%graph.y 393
    }
    @ ./in core:container:in {
      #%graph.x 936
      #%graph.y 593
    }
    @ ./videos core:container {
      #%graph.x 568
      #%graph.y 343
      #%praxis.version 4.1.1
      @ ./colour-0 video:gl:p2d {
        #%graph.x 272
        #%graph.y 669
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -12164179
        .hex-rgb 4663AD
        .red 70.0
        .green 99.0
        .blue 173.0
        .hue 0.6190476190476191
        .saturation 0.5953757166862488
        .brightness 0.6784313917160034
      }
      @ ./player-buildings video:player {
        #%graph.x -205
        #%graph.y 411
        .video [file "resources/buildings.mp4"]
        .position 0.8313541782022579
        .zoom 1.061933405315502
      }
      @ ./screen-out video:container:out {
        #%graph.x 1096
        #%graph.y 192
      }
      @ ./web-cam video:capture {
        #%graph.x 28
        #%graph.y 654
        .device 3
        .source-width 800
        .source-height 500
        .source-fps 30
      }
      @ ./colour-correction-1 video:gl:p2d {
        #%graph.x 196
        #%graph.y 491
        #%graph.comment \n
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double contrast;
    @P(3)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double saturation;
    @P(4)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double brightness;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"contrast\", contrast);
        shader.set(\"saturation\", saturation);
        shader.set(\"brightness\", brightness);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float contrast;
uniform float saturation;
uniform float brightness;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}

void main()
\{
	vec4 inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec3 outColor = rgb2hsv(inColor.rgb);
        outColor.g *= saturation;
        outColor.rgb = hsv2rgb(outColor);
        outColor.rgb = outColor.rgb*contrast;
	outColor.rgb += vec3(brightness, brightness, brightness)-vec3(1,1,1);
	gl_FragColor.rgb = outColor.rgb;
        gl_FragColor.a = 1.0;
\}




"
        .contrast 2.079874126521357
        .saturation 0.0
        .brightness 0.648619431557137
      }
      @ ./colour-correction-0 video:gl:p2d {
        #%graph.x 757
        #%graph.y 170
        #%graph.comment \n
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double contrast;
    @P(3)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double saturation;
    @P(4)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double brightness;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"contrast\", contrast);
        shader.set(\"saturation\", saturation);
        shader.set(\"brightness\", brightness);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float contrast;
uniform float saturation;
uniform float brightness;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}

void main()
\{
	vec4 inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec3 outColor = rgb2hsv(inColor.rgb);
        outColor.g *= saturation;
        outColor.rgb = hsv2rgb(outColor);
        outColor.rgb = outColor.rgb*contrast;
	outColor.rgb += vec3(brightness, brightness, brightness)-vec3(1,1,1);
	gl_FragColor.rgb = outColor.rgb;
        gl_FragColor.a = 1.0;
\}




"
        .contrast 4.0
        .saturation 0.0
        .brightness 0.0
      }
      @ ./video-out-plain video:container:out {
        #%graph.x 757
        #%graph.y 361
      }
      @ ./video-out-composite-1 video:container:out {
        #%graph.x 951
        #%graph.y 719
      }
      @ ./video-out-composite-0 video:container:out {
        #%graph.x 970
        #%graph.y 541
      }
      @ ./composite-0 video:composite {
        #%graph.x 724
        #%graph.y 494
        .mix 0.36936936936936937
      }
      @ ./composite-1 video:composite {
        #%graph.x 682
        #%graph.y 704
        .mix 0.4144144144144144
      }
      @ ./colour-1 video:gl:p2d {
        #%graph.x 444
        #%graph.y 756
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -9484259
        .hex-rgb 6F481D
        .red 111.0
        .green 72.0
        .blue 29.0
        .hue 0.08843537414965986
        .saturation 0.7414965986394558
        .brightness 0.43537414965986393
      }
      @ ./start core:container:in {
        #%graph.x -315
        #%graph.y 270
      }
      @ ./screencasts video:xfader {
        #%graph.x 476
        #%graph.y 55
      }
      @ ./stream-6666-local video:capture {
        #%graph.x -106
        #%graph.y 55
        #%graph.comment Run locally:\ngst-launch-1.0 -v ximagesrc starty=1080 use-damage=false xname=/usr/lib/torcs/torcs-bin ! videoconvert ! videoscale ! video/x-raw,format=I420 ! jpegenc ! rtpjpegpay ! udpsink host=localhost port=6666
        .code "import org.praxislive.video.gstreamer.*;


    enum ResizeMode \{Stretch, Scale, Crop\};
    
    @T(1) Trigger play;
    @T(2) Trigger stop;
    
    @P(1) @Type.String(emptyIsDefault = true, suggested = \{\"\", \"1\", \"2\", \"3\", \"4\"\})
    Property device;
    @P(2)
    ResizeMode resizeMode;
    @P(3) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignX;
    @P(4) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignY;
    @P(5) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoomX;
    @P(6) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoomY;
    @P(7) @Config.Port(false)
    Property sourceWidth;
    @P(8) @Config.Port(false)
    Property sourceHeight;
    @P(9) @Config.Port(false)
    Property sourceFps;
    @P(10) @ReadOnly
    String state;
    
    @Inject VideoCapture capture;

    @AuxOut(1) Output ready;
    @AuxOut(2) Output error;
    @AuxOut(3) Output eos;
    

    @Override
    public void init() \{
        device.linkAs(Value::toString, capture::device);
        play.link(() -> \{
            capture.requestFrameSize(i(sourceWidth), i(sourceHeight))
                    .requestFrameRate(d(sourceFps))
                    .play();
        \});
        stop.link(capture::stop);
        capture.onReady(ready::send);
        capture.onError(msg -> \{
            log(ERROR, msg);
            error.send(msg);
        \});
        capture.onEOS(eos::send);
    \}

    @Override
    public void draw() \{
        capture.render(this::drawFrame);
        state = capture.state().toString();
    \}

    void drawFrame(PImage frame) \{
        double outWidth = zoomX * frame.width;
        double outHeight = zoomY * frame.height;
        if (resizeMode == ResizeMode.Stretch) \{
            outWidth *= (double) width / frame.width;
            outHeight *= (double) height / frame.height;
        \} else if (resizeMode == ResizeMode.Scale) \{
            double r = min((double) width / frame.width, (double) height / frame.height);
            outWidth *= r;
            outHeight *= r;
        \}
        image(frame, alignX * (width - outWidth),
                alignY * (height - outHeight),
                outWidth,
                outHeight);
    \}
    
"
        .device "udpsrc port=6666 ! application/x-rtp,encoding-name=JPEG,payload=26 ! rtpjpegdepay ! jpegdec"
        .resize-mode Crop
        .align-x 1
        .align-y 1.0
        .zoom-y 1.111
      }
      @ ./stream-9999-remote video:capture {
        #%graph.x 190
        #%graph.y 133
        .code "import org.praxislive.video.gstreamer.*;


    enum ResizeMode \{Stretch, Scale, Crop\};
    
    @T(1) Trigger play;
    @T(2) Trigger stop;
    
    @P(1) @Type.String(emptyIsDefault = true, suggested = \{\"\", \"1\", \"2\", \"3\", \"4\"\})
    Property device;
    @P(2)
    ResizeMode resizeMode;
    @P(3) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignX;
    @P(4) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignY;
    @P(5) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoomX;
    @P(6) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoomY;
    @P(7) @Config.Port(false)
    Property sourceWidth;
    @P(8) @Config.Port(false)
    Property sourceHeight;
    @P(9) @Config.Port(false)
    Property sourceFps;
    @P(10) @ReadOnly
    String state;
    
    @Inject VideoCapture capture;

    @AuxOut(1) Output ready;
    @AuxOut(2) Output error;
    @AuxOut(3) Output eos;
    

    @Override
    public void init() \{
        device.linkAs(Value::toString, capture::device);
        play.link(() -> \{
            capture.requestFrameSize(i(sourceWidth), i(sourceHeight))
                    .requestFrameRate(d(sourceFps))
                    .play();
        \});
        stop.link(capture::stop);
        capture.onReady(ready::send);
        capture.onError(msg -> \{
            log(ERROR, msg);
            error.send(msg);
        \});
        capture.onEOS(eos::send);
    \}

    @Override
    public void draw() \{
        capture.render(this::drawFrame);
        state = capture.state().toString();
    \}

    void drawFrame(PImage frame) \{
        double outWidth = zoomX * frame.width;
        double outHeight = zoomY * frame.height;
        if (resizeMode == ResizeMode.Stretch) \{
            outWidth *= (double) width / frame.width;
            outHeight *= (double) height / frame.height;
        \} else if (resizeMode == ResizeMode.Scale) \{
            double r = min((double) width / frame.width, (double) height / frame.height);
            outWidth *= r;
            outHeight *= r;
        \}
        image(frame, alignX * (width - outWidth),
                alignY * (height - outHeight),
                outWidth,
                outHeight);
    \}
    
"
        .device "udpsrc port=9999 ! application/x-rtp,encoding-name=JPEG,payload=26 ! rtpjpegdepay ! jpegdec"
        .align-x 1
        .align-y 1.0
      }
      ~ ./colour-correction-0!out ./screen-out!in
      ~ ./player-buildings!out ./colour-correction-1!in
      ~ ./colour-correction-1!out ./video-out-plain!in
      ~ ./colour-correction-1!out ./composite-0!in
      ~ ./colour-0!out ./composite-0!src
      ~ ./composite-0!out ./video-out-composite-0!in
      ~ ./colour-1!out ./composite-1!src
      ~ ./colour-correction-1!out ./composite-1!in
      ~ ./composite-1!out ./video-out-composite-1!in
      ~ ./start!out ./player-buildings!play
      ~ ./screencasts!out ./colour-correction-0!in
      ~ ./start!out ./stream-6666-local!play
      ~ ./stream-6666-local!out ./screencasts!in-1
      ~ ./start!out ./stream-9999-remote!play
      ~ ./stream-9999-remote!out ./screencasts!in-2
    }
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./control!properties-out ./properties-out!in
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./in!out ./vor-colours!voronoi-in
    ~ ./vor-colours!out ./out!in
    ~ ./strobe-control!edges-7 ./strobes!in-7
    ~ ./strobes!out-0 ./vor-colours!in-0
    ~ ./videos!screen-out ./vor-colours!in-0
    ~ ./videos!screen-out ./vor-colours!in-1
    ~ ./ping-control!ping-0-red ./strobe-control!strobe-0
    ~ ./ping-control!ping-1-yellow ./strobe-control!strobe-1
    ~ ./videos!video-out-composite-0 ./vor-colours!in-6
    ~ ./videos!video-out-composite-1 ./vor-colours!in-5
    ~ ./videos!video-out-plain ./vor-colours!in-4
    ~ ./videos!video-out-plain ./vor-colours!in-3
    ~ ./videos!video-out-plain ./vor-colours!in-2
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-2
    ~ ./strobes!out-2 ./vor-colours!in-6
    ~ ./strobes!out-1 ./vor-colours!in-5
    ~ ./control!video-start ./videos!start
  }
  @ ./videos-control core:routing:send {
    #%graph.x -427
    #%graph.y 46
    .address /video/videos/properties-in.in
  }
  ~ ./voronoi-generator!voronoi-out ./bw!in
  ~ ./voronoi-generator!properties-out ./bw-control!in
  ~ ./bw!out ./x-fader!bw
  ~ ./voronoi-generator!properties-out ./clouds-control!in
  ~ ./ping-control!ping-0-red ./voronoi-generator!move-cells
  ~ ./voronoi-generator!voronoi-out ./clouds!in
  ~ ./voronoi-generator!properties-out ./colours-control!in
  ~ ./voronoi-generator!voronoi-out ./colours!in
  ~ ./x-fader!out ./screen!in
  ~ ./clouds!out ./x-fader!clouds
  ~ ./colours!out ./x-fader!colours
  ~ ./start!out ./voronoi-generator!move-cells
  ~ ./voronoi-generator!voronoi-out ./videos!in
  ~ ./videos!out ./x-fader!videos
  ~ ./voronoi-generator!properties-out ./videos-control!in
}
