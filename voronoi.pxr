@ /voronoi root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1100
    #%graph.y 365
    .rotation 0
    .always-on-top true
    .show-cursor true
  }
  @ ./vor video:gl:p2d {
    #%graph.x 848
    #%graph.y 59
    .code "import org.kynosarges.tektosyne.geometry.*;


    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    @P(3) @Type.Integer(def = 6, min = 2, max = 7) @OnChange(\"initPoints\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidth\") double edgeWidthExp;
    double edgeWidth;

    Color\[\] colors;
    PointD\[\] points;
    
    Property\[\]\[\] moves;
    
    RectD clip;
    VoronoiResults results;
    
    @Inject Property m0x;
    @Inject Property m1x;
    @Inject Property m2x;
    @Inject Property m3x;
    @Inject Property m4x;
    @Inject Property m5x;
    @Inject Property m6x;
    
    @Inject Property m0y;
    @Inject Property m1y;
    @Inject Property m2y;
    @Inject Property m3y;
    @Inject Property m4y;
    @Inject Property m5y;
    @Inject Property m6y;
    
    @Inject PArray movesX;
    @Inject PArray movesY;
    
    @Override
    public void setup() \{
        smooth(255);
        background(0);
        initPoints();
        updateEdgeWidth();
    \}
    
    void updateEdgeWidth() \{
        edgeWidth = pow(2, edgeWidthExp);
    \}
    
    void initPoints() \{
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);

        moves = new Property\[cellsCount\]\[\];
        moves\[0\] = new Property\[\] \{m0x, m0y\};
        moves\[1\] = new Property\[\] \{m1x, m1y\};
        if(cellsCount > 2) moves\[2\] = new Property\[\] \{m2x, m2y\};
        if(cellsCount > 3) moves\[3\] = new Property\[\] \{m3x, m3y\};
        if(cellsCount > 4) moves\[4\] = new Property\[\] \{m4x, m4y\};
        if(cellsCount > 5) moves\[5\] = new Property\[\] \{m5x, m5y\};
        if(cellsCount > 6) moves\[6\] = new Property\[\] \{m6x, m6y\};

        colors = new Color\[cellsCount\];
        for(int i=0; i<cellsCount; ++i) \{
            colors\[i\] = randomColor();
            moves\[i\]\[0\].set(points\[i\].x);
            moves\[i\]\[1\].set(points\[i\].y);
        \}
        
        clip = new RectD(0, 0, width, height);
        results = Voronoi.findAll(points, clip);
    \}
    
    @T(1)
    public void move() \{
        
        for(int i=0; i<cellsCount; ++i) \{
            Property\[\] move = moves\[i\];

            double nx = -1;
            double ny = -1;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            while (nx < 0 || nx > width || ny < 0 || ny > height) \{
                double alpha = random(PI*2);
                double dx = cos(alpha) * deltaMove;
                double dy = sin(alpha) * deltaMove;
                nx = d(move\[0\]) + dx;
                ny = d(move\[1\]) + dy;
                deltaMove *= 0.7;
            \}
            
            move\[0\].to(nx).in(timeToMove).easing(Easing.cubicOut);
            move\[1\].to(ny).in(timeToMove).easing(Easing.cubicOut);
        \}
    \}

    @Override
    public void draw() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(moves\[i\]\[0\]), d(moves\[i\]\[1\]));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) results = Voronoi.findAll(points, clip);
        
        
        noStroke();

        // draw interior of Voronoi regions
        int j=0;
        for (PointD\[\] region: results.voronoiRegions()) \{
            Color c = colors\[j++\];
            fill(c.r, c.g, c.b);
            PShape r = createShape();
            r.beginShape();
            double\[\] coords = PointD.toDoubles(region);
            for(int i=0; i<coords.length/2; i+=1) \{
                r.vertex(coords\[i*2\], coords\[i*2+1\]);
            \}
            r.endShape();
            shape(r);
        \}
        
        if(edgeWidthExp == 0) \{
            noStroke();
        \} else \{
            strokeWeight(edgeWidth);
            stroke(255);
        \}

        // draw edges of Voronoi diagram
        for (VoronoiEdge edge: results.voronoiEdges) \{
            final PointD start = results.voronoiVertices\[edge.vertex1\];
            final PointD end = results.voronoiVertices\[edge.vertex2\];

            line(start.x, start.y, end.x, end.y);
        \}

        
        if (false) \{
            // draw generator points
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                textSize(20);
                text(i, point.x, point.y);
            \}
        \}
    \}
    
    static class Point \{
      double x,y; Color c;
      Point(double x,double y, Color c) \{ this.x=x; this.y=y; this.c=c; \}
    \}
    Point randomPoint() \{ return new Point(random(width), random(height), randomColor()); \}
    
    static class Color \{
        double r, g, b;
        Color(double r, double g, double b) \{ this.r=r; this.g=g; this.b=b; \}
    \}
    Color randomColor() \{ return new Color(random(256), random(256), random(256)); \}
"
    .edge-width-exp 4.838709677419354
  }
  @ ./voronoi-composite video:custom {
    #%graph.x 724
    #%graph.y 393
    .code "import org.kynosarges.tektosyne.geometry.*;

    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage inEdges;
    
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out0, out1, out2, out3, outEdges;
        
    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    
    @P(3) @Type.Integer(def = 6, min = 2, max = 7) @OnChange(\"updateCellsCount\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidthAndClipRect\") double edgeWidthExp;
    
    @P(10) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell0InputNo;
    @P(11) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell1InputNo;
    @P(12) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell2InputNo;
    @P(13) @Type.Integer(def = 3, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell3InputNo;
    @P(14) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell4InputNo;
    @P(15) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell5InputNo;
    @P(16) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateCellsInput\") int cell6InputNo;

    @P(17) @Type.Boolean(def = false) boolean drawDots;
    
    @P(18) @Type.Boolean(def = true) boolean justColours;
    
    List<Colour> colours = randomColours(7);
    
    // Cell properties
    List<Cell> cells = new ArrayList<>();
    
    // Calculated width of cell edges
    double edgeWidth;
    
    // Limit for voronoi cells
    RectD clip;
    
    // Current state of cells geometry
    VoronoiResults results;
    
    // Current coordinates of cells centers
    PointD\[\] points;
    
    // Moves
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y;

    @Override
    public void setup() \{
        updateEdgeWidthAndClipRect();
        updateCellsCount();

        smooth();
        background(0);
    \}

    @Override
    public void draw() \{
        updateCellsGeometry();
        cells.forEach(cell -> drawCell(cell));
        drawCenters(outEdges);
        drawEdges(outEdges);
        drawOutput(inEdges, outEdges);
    \}
    
    void drawCell(Cell cell) \{
        cell.out.ifPresent(out -> \{
            out.blendMode(BLEND);
             // if no edges, expanding mask by one pixel to avoid artifacts
            out.strokeWeight(edgeWidthExp > 0.1 ? 0 : 1);

            PointD\[\] region = results.voronoiRegions()\[cell.no\];
            double\[\] coords = PointD.toDoubles(region);
            Colour c = cell.colour;
            if (justColours) \{
                out.fill(c.r, c.g, c.b);
                out.stroke(c.r, c.g, c.b);
            \} else \{
                out.fill(255);
                out.stroke(255);
            \}

            out.beginShape();
            for(int i=0; i<coords.length/2; i+=1) \{
                out.vertex(coords\[i*2\], coords\[i*2+1\]);
            \}
            out.endShape(CLOSE);
            
            cell.in.ifPresent(in -> drawOutput(in, out));
        \});
    \}
    
    void drawCenters(PGraphics out) \{
        if(drawDots) \{
            out.blendMode(BLEND);
            out.fill(255);
            out.noStroke();
            
            double dotSize = 20;
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                out.rect(point.x-dotSize/2, point.y-dotSize/2, dotSize, dotSize);
            \}
        \}
    \}
    
    void drawEdges(PGraphics out) \{
        if(edgeWidthExp > 0.1) \{
            out.blendMode(BLEND);
            out.strokeWeight(edgeWidth*1.1);
            out.stroke(255);
            
            for (VoronoiEdge edge: results.voronoiEdges) \{
                final PointD start = results.voronoiVertices\[edge.vertex1\];
                final PointD end = results.voronoiVertices\[edge.vertex2\];

                out.line(start.x, start.y, end.x, end.y);
            \}
        \}
    \}
    
    void drawOutput(PImage in, PGraphics out) \{
        if (!justColours) \{
            out.blendMode(MULTIPLY);
            out.image(in, 0, 0);
        \}
        blendMode(ADD);
        copy(out);
        release(out);
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(cells.get(i).moveX), d(cells.get(i).moveY));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) \{
            results = Voronoi.findAll(points, clip);
        \}
    \}
    
    void updateEdgeWidthAndClipRect() \{
        edgeWidth = pow(2, edgeWidthExp);
        clip = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
    \}
    
    @T(1)
    public void moveCenters() \{
        for(Cell cell: cells) \{
            double nx, ny;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            do \{
                double alpha = random(PI*2);
                nx = cell.x() + cos(alpha) * deltaMove;
                ny = cell.y() + sin(alpha) * deltaMove;
                deltaMove *= 0.7; // slow down to avoid infinite loop
            \} while (nx < 0 || nx > width || ny < 0 || ny > height);
            
            cell.startMovingTo(nx, ny, timeToMove);
        \}
    \}
    
    void updateCellsInput() \{
        int\[\] cellInputNos = new int\[\] \{ cell0InputNo, cell1InputNo, cell2InputNo, cell3InputNo, cell4InputNo, cell5InputNo, cell6InputNo \};
        PGraphics\[\] outs = \{ null, out0, out1, out2, out3 \};
        PImage\[\] ins = \{ null, in0, in1, in2, in3 \};
        Property\[\]\[\] moves = \{ \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\},
            \{m3x, m3y\}, \{m4x, m4y\}, \{m5x, m5y\}, \{m6x, m6y\} \};

        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<cellsCount; ++i) \{
            int inputNo = cellInputNos\[i\];
            cells.add(new Cell(
                    cells.size(),
                    Optional.ofNullable(ins\[inputNo + 1\]), 
                    Optional.ofNullable(outs\[inputNo + 1\]), 
                    colours.get(i),
                    moves\[i\]\[0\],
                    moves\[i\]\[1\]));
        \}
        this.cells = cells;
    \}
    
    void updateCellsCount() \{
        updateCellsInput();
        
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);
        results = Voronoi.findAll(points, clip);        

        // reset moves
        for(int i=0; i<cellsCount; ++i) \{
            cells.get(i).jumpTo(points\[i\].x, points\[i\].y);
        \}
    \}
    
    static class Cell \{
        final int no;
        final Optional<PImage> in;
        final Optional<PGraphics> out;
        final Colour colour;
        final Property moveX;
        final Property moveY;
        
        Cell(int no, Optional<PImage> in, Optional<PGraphics> out, Colour colour, 
                Property moveX, Property moveY) \{
            this.no = no;
            this.in = in;
            this.out = out;
            this.colour = colour;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
    \}
    
    static class Colour \{
        final double r, g, b;
        
        Colour(double r, double g, double b) \{ 
            this.r=r; 
            this.g=g; 
            this.b=b; 
        \}
    \}
    
    List<Colour> randomColours(int count) \{ 
        return Stream.generate(() -> new Colour(random(255), random(255), random(255)))
                .limit(count).collect(Collectors.toList());
    \}
"
    .time-to-move 0.5357142857142857
    .edge-width-exp 3.7142857142857144
    .just-colours false
  }
  @ ./capture-1 video:capture {
    #%graph.x 119
    #%graph.y 701
    .device 2
    .resize-mode Crop
    .align-x 0.5887096774193549
    .align-y 0.0
    .zoom 1.8509600756236193
  }
  @ ./color video:custom {
    #%graph.x 124
    #%graph.y 207
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 37.016129032258064
    .green 205.64516129032256
    .blue 185.08064516129033
  }
  @ ./color1 video:custom {
    #%graph.x 418
    #%graph.y 59
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 121.33064516129033
    .green 217.98387096774195
    .blue 164.51612903225805
  }
  @ ./color2 video:custom {
    #%graph.x 119
    #%graph.y 365
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 187.13709677419357
    .green 84.31451612903226
    .blue 176.85483870967744
  }
  @ ./player-1 video:player {
    #%graph.x 418
    #%graph.y 244
    .video [file "resources/horse.mp4"]
    .position 0.7783756806277707
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x 540
    #%graph.y 671
  }
  @ ./color3 video:custom {
    #%graph.x 114
    #%graph.y 530
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 255.0
    .green 255.0
    .blue 67.86290322580645
  }
  @ ./gl-gradients video:gl:p2d {
    #%graph.x 333
    #%graph.y 605
    .code "

    @P(1)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double x;
    @P(2)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double y;
    @P(3)
    @Config.Port(false)
    boolean mouseInput;

    void updateUniforms() \{
        shader.set(\"time\", millis() / 1000.0);
        if (mouseInput) \{
            x = (double) mouseX / width;
            y = 1.0 - ((double) mouseY / height);
        \}
        shader.set(\"mouse\", x, y);
    \}

    // BOILERPLATE BELOW
    @P(0)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEF_FRAG)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    final String DEF_FRAG
            = \"uniform float time;\\n\"
            + \"uniform vec2 mouse;\\n\"
            + \"uniform vec2 resolution;\\n\"
            + \"\\n\"
            + \"void main() \{\\n\"
            + \"    // fragment position\\n\"
            + \"    vec2 pos = gl_FragCoord.xy/resolution.xy;\\n\"
            + \"    vec2 dist = mouse - pos;\\n\"
            + \"    vec3 white = vec3(1.0 - length(dist));\\n\"
            + \"    gl_FragColor = vec4(white, 1.0);\\n\"
            + \"\}\";

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER,
                    fragment.isEmpty() ? DEF_FRAG : fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}

"
    .fragment "uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main() \{
    vec2 pos = ( gl_FragCoord.xy / resolution.xy ) * 8.0 - 13.0;
    float x = sin(time*4 + length(pos.xy));
    float y = cos(time*18 + length(pos.xy));
    float white = x * y * 3.5;
    gl_FragColor = vec4(white, white, white, 1.0 );
\}"
    .x 0.44375
    .y 0.015000000000000013
    .mouse-input true
  }
  ~ ./timer-1!out ./voronoi-composite!move-centers
  ~ ./color2!out ./voronoi-composite!in-2
  ~ ./color3!out ./voronoi-composite!in-3
  ~ ./gl-gradients!out ./voronoi-composite!in-edges
  ~ ./player-1!out ./voronoi-composite!in-0
  ~ ./voronoi-composite!out ./screen!in
  ~ ./color!out ./voronoi-composite!in-1
}
