@ /voronoi root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1100
    #%graph.y 365
    .rotation 0
    .always-on-top true
    .show-cursor true
  }
  @ ./vor video:gl:p2d {
    #%graph.x 848
    #%graph.y 59
    .code "import org.kynosarges.tektosyne.geometry.*;


    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    @P(3) @Type.Integer(def = 6, min = 2, max = 7) @OnChange(\"initPoints\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidth\") double edgeWidthExp;
    double edgeWidth;

    Color\[\] colors;
    PointD\[\] points;
    
    Property\[\]\[\] moves;
    
    RectD clip;
    VoronoiResults results;
    
    @Inject Property m0x;
    @Inject Property m1x;
    @Inject Property m2x;
    @Inject Property m3x;
    @Inject Property m4x;
    @Inject Property m5x;
    @Inject Property m6x;
    
    @Inject Property m0y;
    @Inject Property m1y;
    @Inject Property m2y;
    @Inject Property m3y;
    @Inject Property m4y;
    @Inject Property m5y;
    @Inject Property m6y;
    
    @Inject PArray movesX;
    @Inject PArray movesY;
    
    @Override
    public void setup() \{
        smooth(255);
        background(0);
        initPoints();
        updateEdgeWidth();
    \}
    
    void updateEdgeWidth() \{
        edgeWidth = pow(2, edgeWidthExp);
    \}
    
    void initPoints() \{
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);

        moves = new Property\[cellsCount\]\[\];
        moves\[0\] = new Property\[\] \{m0x, m0y\};
        moves\[1\] = new Property\[\] \{m1x, m1y\};
        if(cellsCount > 2) moves\[2\] = new Property\[\] \{m2x, m2y\};
        if(cellsCount > 3) moves\[3\] = new Property\[\] \{m3x, m3y\};
        if(cellsCount > 4) moves\[4\] = new Property\[\] \{m4x, m4y\};
        if(cellsCount > 5) moves\[5\] = new Property\[\] \{m5x, m5y\};
        if(cellsCount > 6) moves\[6\] = new Property\[\] \{m6x, m6y\};

        colors = new Color\[cellsCount\];
        for(int i=0; i<cellsCount; ++i) \{
            colors\[i\] = randomColor();
            moves\[i\]\[0\].set(points\[i\].x);
            moves\[i\]\[1\].set(points\[i\].y);
        \}
        
        clip = new RectD(0, 0, width, height);
        results = Voronoi.findAll(points, clip);
    \}
    
    @T(1)
    public void move() \{
        
        for(int i=0; i<cellsCount; ++i) \{
            Property\[\] move = moves\[i\];

            double nx = -1;
            double ny = -1;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            while (nx < 0 || nx > width || ny < 0 || ny > height) \{
                double alpha = random(PI*2);
                double dx = cos(alpha) * deltaMove;
                double dy = sin(alpha) * deltaMove;
                nx = d(move\[0\]) + dx;
                ny = d(move\[1\]) + dy;
                deltaMove *= 0.7;
            \}
            
            move\[0\].to(nx).in(timeToMove).easing(Easing.cubicOut);
            move\[1\].to(ny).in(timeToMove).easing(Easing.cubicOut);
        \}
    \}

    @Override
    public void draw() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(moves\[i\]\[0\]), d(moves\[i\]\[1\]));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) results = Voronoi.findAll(points, clip);
        
        
        noStroke();

        // draw interior of Voronoi regions
        int j=0;
        for (PointD\[\] region: results.voronoiRegions()) \{
            Color c = colors\[j++\];
            fill(c.r, c.g, c.b);
            PShape r = createShape();
            r.beginShape();
            double\[\] coords = PointD.toDoubles(region);
            for(int i=0; i<coords.length/2; i+=1) \{
                r.vertex(coords\[i*2\], coords\[i*2+1\]);
            \}
            r.endShape();
            shape(r);
        \}
        
        if(edgeWidthExp == 0) \{
            noStroke();
        \} else \{
            strokeWeight(edgeWidth);
            stroke(255);
        \}

        // draw edges of Voronoi diagram
        for (VoronoiEdge edge: results.voronoiEdges) \{
            final PointD start = results.voronoiVertices\[edge.vertex1\];
            final PointD end = results.voronoiVertices\[edge.vertex2\];

            line(start.x, start.y, end.x, end.y);
        \}

        
        if (false) \{
            // draw generator points
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                textSize(20);
                text(i, point.x, point.y);
            \}
        \}
    \}
    
    static class Point \{
      double x,y; Color c;
      Point(double x,double y, Color c) \{ this.x=x; this.y=y; this.c=c; \}
    \}
    Point randomPoint() \{ return new Point(random(width), random(height), randomColor()); \}
    
    static class Color \{
        double r, g, b;
        Color(double r, double g, double b) \{ this.r=r; this.g=g; this.b=b; \}
    \}
    Color randomColor() \{ return new Color(random(256), random(256), random(256)); \}
"
    .edge-width-exp 4.838709677419354
  }
  @ ./voronoi-composite video:custom {
    #%graph.x 724
    #%graph.y 393
    .code "import org.kynosarges.tektosyne.geometry.*;

    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage inEdges;
    
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out0; 
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out1;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out2;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out3;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics outEdges;
        
    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    @P(3) @Type.Integer(def = 6, min = 2, max = 7) @OnChange(\"initPoints\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidth\") double edgeWidthExp;
    
    @P(10) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell0InputNo;
    @P(11) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell1InputNo;
    @P(12) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell2InputNo;
    @P(13) @Type.Integer(def = 3, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell3InputNo;
    @P(14) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell4InputNo;
    @P(15) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell5InputNo;
    @P(16) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell6InputNo;

    @P(17) @Type.Boolean(def = false) boolean drawDots;
    
    @P(18) @Type.Boolean(def = true) boolean justColours;
    
    Map<Integer, PGraphics> outByCell = new HashMap<>();
    Map<Integer, PImage> inByCell = new HashMap<>();
    
    double edgeWidth;

    Color\[\] colors;
    PointD\[\] points;
    
    Property\[\]\[\] moves;
    
    RectD clip;
    VoronoiResults results;
    
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y;
    
    @Inject PArray movesX;
    @Inject PArray movesY;
    
    @Override
    public void setup() \{
        smooth();
        background(0);
        initPoints();
        updateInputsOutputs();
        updateEdgeWidth();
    \}
    
    void initPoints() \{
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);

        moves = new Property\[cellsCount\]\[\];
        moves\[0\] = new Property\[\] \{m0x, m0y\};
        moves\[1\] = new Property\[\] \{m1x, m1y\};
        if(cellsCount > 2) moves\[2\] = new Property\[\] \{m2x, m2y\};
        if(cellsCount > 3) moves\[3\] = new Property\[\] \{m3x, m3y\};
        if(cellsCount > 4) moves\[4\] = new Property\[\] \{m4x, m4y\};
        if(cellsCount > 5) moves\[5\] = new Property\[\] \{m5x, m5y\};
        if(cellsCount > 6) moves\[6\] = new Property\[\] \{m6x, m6y\};

        colors = new Color\[cellsCount\];
        for(int i=0; i<cellsCount; ++i) \{
            colors\[i\] = randomColor();
            moves\[i\]\[0\].set(points\[i\].x);
            moves\[i\]\[1\].set(points\[i\].y);
        \}
        
        clip = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
        results = Voronoi.findAll(points, clip);
    \}
    
    @T(1)
    public void move() \{
        
        for(int i=0; i<cellsCount; ++i) \{
            Property\[\] move = moves\[i\];

            double nx = -1;
            double ny = -1;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            while (nx < 0 || nx > width || ny < 0 || ny > height) \{
                double alpha = random(PI*2);
                double dx = cos(alpha) * deltaMove;
                double dy = sin(alpha) * deltaMove;
                nx = d(move\[0\]) + dx;
                ny = d(move\[1\]) + dy;
                deltaMove *= 0.7;
            \}
            
            move\[0\].to(nx).in(timeToMove).easing(Easing.cubicOut);
            move\[1\].to(ny).in(timeToMove).easing(Easing.cubicOut);
        \}
    \}

    @Override
    public void draw() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(moves\[i\]\[0\]), d(moves\[i\]\[1\]));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) results = Voronoi.findAll(points, clip);
        
        outByCell.entrySet().stream().filter(e -> e.getKey() >= 0 && e.getKey() < cellsCount).forEach(e -> \{
            int cellNo = e.getKey();
            PGraphics out = e.getValue();
            PImage in = inByCell.get(cellNo);
            out.blendMode(BLEND);
            out.strokeWeight(edgeWidthExp > 0.1 ? 0 : 1);

            PointD\[\] region = results.voronoiRegions()\[cellNo\];
            double\[\] coords = PointD.toDoubles(region);
            Color c = colors\[cellNo\];
            if (justColours) \{
                out.fill(c.r, c.g, c.b);
                out.stroke(c.r, c.g, c.b);
            \} else \{
                out.fill(255);
                out.stroke(255);
            \}

            out.beginShape();
            for(int i=0; i<coords.length/2; i+=1) \{
                out.vertex(coords\[i*2\], coords\[i*2+1\]);
            \}
            out.endShape(CLOSE);

            if (!justColours) \{
                out.blendMode(MULTIPLY);
                out.image(in, 0, 0);
            \}
            blendMode(ADD);
            copy(out);
            release(out);
        \});
        
        PGraphics out = outEdges;
        out.fill(255);
        out.blendMode(BLEND);
        out.noStroke();
        
        // draw generator points
        if(drawDots) \{
            double dotSize = 20;
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                out.rect(point.x-dotSize/2, point.y-dotSize/2, dotSize, dotSize);
            \}
        \}
        
        // draw edges of Voronoi diagram
        if(edgeWidthExp > 0.1) \{
            out.strokeWeight(edgeWidth*1.1);
            out.stroke(255);
            for (VoronoiEdge edge: results.voronoiEdges) \{
                final PointD start = results.voronoiVertices\[edge.vertex1\];
                final PointD end = results.voronoiVertices\[edge.vertex2\];

                out.line(start.x, start.y, end.x, end.y);
            \}
        \}

        if (!justColours) \{
            out.blendMode(MULTIPLY);
            out.image(inEdges, 0, 0);
        \}
        blendMode(ADD);
        copy(out);
        release(out);
    \}
    
    void updateEdgeWidth() \{
        edgeWidth = pow(2, edgeWidthExp);
    \}
    
    void updateInputsOutputs() \{
        Map<Integer, PGraphics> outByCell = new HashMap<>();
        if(cell0InputNo >= 0) outByCell.put(0, getOutByNo(cell0InputNo));
        if(cell1InputNo >= 0) outByCell.put(1, getOutByNo(cell1InputNo));
        if(cell2InputNo >= 0) outByCell.put(2, getOutByNo(cell2InputNo));
        if(cell3InputNo >= 0) outByCell.put(3, getOutByNo(cell3InputNo));
        if(cell4InputNo >= 0) outByCell.put(4, getOutByNo(cell4InputNo));
        if(cell5InputNo >= 0) outByCell.put(5, getOutByNo(cell5InputNo));
        if(cell6InputNo >= 0) outByCell.put(6, getOutByNo(cell6InputNo));
        
        Map<Integer, PImage> inByCell = new HashMap<>();
        if(cell0InputNo >= 0) inByCell.put(0, getInByNo(cell0InputNo));
        if(cell1InputNo >= 0) inByCell.put(1, getInByNo(cell1InputNo));
        if(cell2InputNo >= 0) inByCell.put(2, getInByNo(cell2InputNo));
        if(cell3InputNo >= 0) inByCell.put(3, getInByNo(cell3InputNo));
        if(cell4InputNo >= 0) inByCell.put(4, getInByNo(cell4InputNo));
        if(cell5InputNo >= 0) inByCell.put(5, getInByNo(cell5InputNo));
        if(cell6InputNo >= 0) inByCell.put(6, getInByNo(cell6InputNo));
        
        this.outByCell = outByCell;
        this.inByCell = inByCell;
    \}
    
    PGraphics getOutByNo(int no) \{
        switch(no) \{
            case 0: return out0;
            case 1: return out1;
            case 2: return out2;
            case 3: return out3;
            default: throw new RuntimeException(\"Invalid output number\");
        \}
    \}
    
    PImage getInByNo(int no) \{
        switch(no) \{
            case 0: return in0;
            case 1: return in1;
            case 2: return in2;
            case 3: return in3;
            default: throw new RuntimeException(\"Invalid input number\");
        \}
    \}
    
    static class Color \{
        double r, g, b;
        Color(double r, double g, double b) \{ this.r=r; this.g=g; this.b=b; \}
    \}
    Color randomColor() \{ return new Color(random(256), random(256), random(256)); \}
 
"
    .delta-move 80.83832335329342
    .time-to-move 0.8982035928143712
    .cells-count 7
    .edge-width-exp 3.592814371257485
    .cell-4-input-no 1
    .cell-5-input-no 2
    .cell-6-input-no 0
    .draw-dots true
  }
  @ ./capture-1 video:capture {
    #%graph.x 119
    #%graph.y 701
    .device 2
    .resize-mode Crop
    .align-x 0.5887096774193549
    .align-y 0.0
    .zoom 1.8509600756236193
  }
  @ ./color video:custom {
    #%graph.x 124
    #%graph.y 207
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 37.016129032258064
    .green 205.64516129032256
    .blue 185.08064516129033
  }
  @ ./color1 video:custom {
    #%graph.x 418
    #%graph.y 59
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 121.33064516129033
    .green 217.98387096774195
    .blue 164.51612903225805
  }
  @ ./color2 video:custom {
    #%graph.x 119
    #%graph.y 365
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 187.13709677419357
    .green 84.31451612903226
    .blue 176.85483870967744
  }
  @ ./player-1 video:player {
    #%graph.x 361
    #%graph.y 518
    .video [file "resources/horse.mp4"]
    .position 0.11649273812889045
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x 540
    #%graph.y 671
  }
  @ ./color3 video:custom {
    #%graph.x 114
    #%graph.y 530
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 255.0
    .green 255.0
    .blue 67.86290322580645
  }
  ~ ./color!out ./voronoi-composite!in-0
  ~ ./voronoi-composite!out ./screen!in
  ~ ./color2!out ./voronoi-composite!in-3
  ~ ./player-1!out ./voronoi-composite!in-1
  ~ ./capture-1!out ./voronoi-composite!in-2
  ~ ./player-1!out ./voronoi-composite!in-edges
  ~ ./timer-1!out ./voronoi-composite!move
}
