@ /voronoi root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1100
    #%graph.y 365
    .rotation 0
    .always-on-top true
    .show-cursor true
  }
  @ ./vor video:gl:p2d {
    #%graph.x 848
    #%graph.y 59
    .code "import org.kynosarges.tektosyne.geometry.*;


    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    @P(3) @Type.Integer(def = 6, min = 2, max = 7) @OnChange(\"initPoints\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidth\") double edgeWidthExp;
    double edgeWidth;

    Color\[\] colors;
    PointD\[\] points;
    
    Property\[\]\[\] moves;
    
    RectD clip;
    VoronoiResults results;
    
    @Inject Property m0x;
    @Inject Property m1x;
    @Inject Property m2x;
    @Inject Property m3x;
    @Inject Property m4x;
    @Inject Property m5x;
    @Inject Property m6x;
    
    @Inject Property m0y;
    @Inject Property m1y;
    @Inject Property m2y;
    @Inject Property m3y;
    @Inject Property m4y;
    @Inject Property m5y;
    @Inject Property m6y;
    
    @Inject PArray movesX;
    @Inject PArray movesY;
    
    @Override
    public void setup() \{
        smooth(255);
        background(0);
        initPoints();
        updateEdgeWidth();
    \}
    
    void updateEdgeWidth() \{
        edgeWidth = pow(2, edgeWidthExp);
    \}
    
    void initPoints() \{
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);

        moves = new Property\[cellsCount\]\[\];
        moves\[0\] = new Property\[\] \{m0x, m0y\};
        moves\[1\] = new Property\[\] \{m1x, m1y\};
        if(cellsCount > 2) moves\[2\] = new Property\[\] \{m2x, m2y\};
        if(cellsCount > 3) moves\[3\] = new Property\[\] \{m3x, m3y\};
        if(cellsCount > 4) moves\[4\] = new Property\[\] \{m4x, m4y\};
        if(cellsCount > 5) moves\[5\] = new Property\[\] \{m5x, m5y\};
        if(cellsCount > 6) moves\[6\] = new Property\[\] \{m6x, m6y\};

        colors = new Color\[cellsCount\];
        for(int i=0; i<cellsCount; ++i) \{
            colors\[i\] = randomColor();
            moves\[i\]\[0\].set(points\[i\].x);
            moves\[i\]\[1\].set(points\[i\].y);
        \}
        
        clip = new RectD(0, 0, width, height);
        results = Voronoi.findAll(points, clip);
    \}
    
    @T(1)
    public void move() \{
        
        for(int i=0; i<cellsCount; ++i) \{
            Property\[\] move = moves\[i\];

            double nx = -1;
            double ny = -1;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            while (nx < 0 || nx > width || ny < 0 || ny > height) \{
                double alpha = random(PI*2);
                double dx = cos(alpha) * deltaMove;
                double dy = sin(alpha) * deltaMove;
                nx = d(move\[0\]) + dx;
                ny = d(move\[1\]) + dy;
                deltaMove *= 0.7;
            \}
            
            move\[0\].to(nx).in(timeToMove).easing(Easing.cubicOut);
            move\[1\].to(ny).in(timeToMove).easing(Easing.cubicOut);
        \}
    \}

    @Override
    public void draw() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(moves\[i\]\[0\]), d(moves\[i\]\[1\]));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) results = Voronoi.findAll(points, clip);
        
        
        noStroke();

        // draw interior of Voronoi regions
        int j=0;
        for (PointD\[\] region: results.voronoiRegions()) \{
            Color c = colors\[j++\];
            fill(c.r, c.g, c.b);
            PShape r = createShape();
            r.beginShape();
            double\[\] coords = PointD.toDoubles(region);
            for(int i=0; i<coords.length/2; i+=1) \{
                r.vertex(coords\[i*2\], coords\[i*2+1\]);
            \}
            r.endShape();
            shape(r);
        \}
        
        if(edgeWidthExp == 0) \{
            noStroke();
        \} else \{
            strokeWeight(edgeWidth);
            stroke(255);
        \}

        // draw edges of Voronoi diagram
        for (VoronoiEdge edge: results.voronoiEdges) \{
            final PointD start = results.voronoiVertices\[edge.vertex1\];
            final PointD end = results.voronoiVertices\[edge.vertex2\];

            line(start.x, start.y, end.x, end.y);
        \}

        
        if (false) \{
            // draw generator points
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                textSize(20);
                text(i, point.x, point.y);
            \}
        \}
    \}
    
    static class Point \{
      double x,y; Color c;
      Point(double x,double y, Color c) \{ this.x=x; this.y=y; this.c=c; \}
    \}
    Point randomPoint() \{ return new Point(random(width), random(height), randomColor()); \}
    
    static class Color \{
        double r, g, b;
        Color(double r, double g, double b) \{ this.r=r; this.g=g; this.b=b; \}
    \}
    Color randomColor() \{ return new Color(random(256), random(256), random(256)); \}
"
    .edge-width-exp 4.838709677419354
  }
  @ ./voronoi-composite video:custom {
    #%graph.x 724
    #%graph.y 393
    .code "import org.kynosarges.tektosyne.geometry.*;


    @In(0) PImage in0;
    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage inEdges;
    
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out0, out1, out2, out3, outEdges;
        
    @P(1) @Type.Number(def = 80, min = 1, max = 200) double deltaMove;
    @P(2) @Type.Number(def = 1, min = 0, max = 15) double timeToMove;
    
    final int MAX_CELLS_COUNT = 7;
    @P(3) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"initPoints\") int cellsCount;
    
    @P(4) @Type.Number(def = 2, min = 0, max = 12) @OnChange(\"updateEdgeWidth\") double edgeWidthExp;
    
    @P(10) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell0InputNo;
    @P(11) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell1InputNo;
    @P(12) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell2InputNo;
    @P(13) @Type.Integer(def = 3, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell3InputNo;
    @P(14) @Type.Integer(def = 0, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell4InputNo;
    @P(15) @Type.Integer(def = 1, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell5InputNo;
    @P(16) @Type.Integer(def = 2, min = -1, max = 3) @OnChange(\"updateInputsOutputs\") int cell6InputNo;

    @P(17) @Type.Boolean(def = false) boolean drawDots;
    
    @P(18) @Type.Boolean(def = true) boolean justColours;
    
    List<Cell> cells = new ArrayList<>();
    
    double edgeWidth;

    @Inject Ref<List<Colour>> colours;
    PointD\[\] points;
    
    Property\[\]\[\] moves;
    PImage\[\] ins;
    PGraphics\[\] outs;
    
    RectD clip;
    VoronoiResults results;
    
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y;
    
    @Override
    public void init() \{
        final RectD bounds = new RectD(0.1 * width, 0.1 * height, 0.9 * width, 0.9 * height);
        points = GeoUtils.randomPoints(cellsCount, bounds, new PointDComparatorY(0), 10);
        Property\[\]\[\] moves = \{ \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\},
            \{m3x, m3y\}, \{m4x, m4y\}, \{m5x, m5y\}, \{m6x, m6y\} \};
        this.moves = moves;
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            moves\[i\]\[0\].set(points\[i\].x);
            moves\[i\]\[1\].set(points\[i\].y);
        \}
        PGraphics\[\] outs = \{out0, out1, out2, out3\};
        this.outs = outs;
        
        PImage\[\] ins = \{in0, in1, in2, in3\};
        this.ins = ins;
    \}
    
    @Override
    public void setup() \{
        smooth();
        background(0);
        colours.init(ArrayList::new);
        colours.apply(l -> \{
            if(l.isEmpty()) \{
                for(int i=0; i<6; ++i) \{
                    l.add(randomColour());
                \}
            \}
        \});
        updateInputsOutputs();
        updateEdgeWidth();
    \}

    @Override
    public void draw() \{
        updateCellsGeometry();
        cells.forEach(cell -> \{
            drawCell(cell.out, cell.no);
            drawInput(cell.in, cell.out);
        \});
        drawCenters(outEdges);
        drawEdges(outEdges);
        drawInput(inEdges, outEdges);
    \}
    
    void drawCell(PGraphics out, int cellNo) \{
        out.blendMode(BLEND);
         // if no edges, expanding mask by one pixel to avoid artifacts
        out.strokeWeight(edgeWidthExp > 0.1 ? 0 : 1);

        PointD\[\] region = results.voronoiRegions()\[cellNo\];
        double\[\] coords = PointD.toDoubles(region);
        Colour c = colours.get().get(cellNo);
        if (justColours) \{
            out.fill(c.r, c.g, c.b);
            out.stroke(c.r, c.g, c.b);
        \} else \{
            out.fill(255);
            out.stroke(255);
        \}

        out.beginShape();
        for(int i=0; i<coords.length/2; i+=1) \{
            out.vertex(coords\[i*2\], coords\[i*2+1\]);
        \}
        out.endShape(CLOSE);
    \}
    
    void drawCenters(PGraphics out) \{
        if(drawDots) \{
            out.blendMode(BLEND);
            out.fill(255);
            out.noStroke();
            
            double dotSize = 20;
            for (int i=0; i<points.length; ++i) \{
                PointD point = points\[i\];
                out.rect(point.x-dotSize/2, point.y-dotSize/2, dotSize, dotSize);
            \}
        \}
    \}
    
    void drawEdges(PGraphics out) \{
        if(edgeWidthExp > 0.1) \{
            out.blendMode(BLEND);
            out.strokeWeight(edgeWidth*1.1);
            out.stroke(255);
            
            for (VoronoiEdge edge: results.voronoiEdges) \{
                final PointD start = results.voronoiVertices\[edge.vertex1\];
                final PointD end = results.voronoiVertices\[edge.vertex2\];

                out.line(start.x, start.y, end.x, end.y);
            \}
        \}
    \}
    
    void drawInput(PImage in, PGraphics out) \{
        if (!justColours) \{
            out.blendMode(MULTIPLY);
            out.image(in, 0, 0);
        \}
        blendMode(ADD);
        copy(out);
        release(out);
    \}
    
    @T(1)
    public void moveCenters() \{
        for(int i=0; i<cellsCount; ++i) \{
            Property\[\] move = moves\[i\];

            double nx = -1;
            double ny = -1;
            double deltaMove = this.deltaMove;
            
            // ensure new coordinate is inside viewport
            while (nx < 0 || nx > width || ny < 0 || ny > height) \{
                double alpha = random(PI*2);
                double dx = cos(alpha) * deltaMove;
                double dy = sin(alpha) * deltaMove;
                nx = d(move\[0\]) + dx;
                ny = d(move\[1\]) + dy;
                deltaMove *= 0.7; // slow down in case we are too far
            \}
            
            move\[0\].to(nx).in(timeToMove).easing(Easing.cubicOut);
            move\[1\].to(ny).in(timeToMove).easing(Easing.cubicOut);
        \}
    \}
    
    void updateCellsGeometry() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PointD oldPoint = points\[i\];
            PointD newPoint = new PointD(d(moves\[i\]\[0\]), d(moves\[i\]\[1\]));
            points\[i\] = newPoint;
            moved |= oldPoint != newPoint;
        \}
        if(moved) \{
            results = Voronoi.findAll(points, clip);
        \}
    \}
    
    void updateEdgeWidth() \{
        edgeWidth = pow(2, edgeWidthExp);
        clip = new RectD(0 - edgeWidth/2, 0 - edgeWidth/2, width + edgeWidth/2, height + edgeWidth/2);
    \}
    
    void updateInputsOutputs() \{
        List<Cell> cells = new ArrayList<>();
        int\[\] cellInputNos = new int\[\] \{ cell0InputNo, cell1InputNo, cell2InputNo, cell3InputNo, cell4InputNo, cell5InputNo \};
        for(int i=0; i<cellInputNos.length; ++i) \{
            int inputNo = cellInputNos\[i\];
            if(inputNo >= 0) \{
                cells.add(new Cell(getInByNo(inputNo), getOutByNo(inputNo), cells.size()));
            \}
        \}
        this.cells = cells;
    \}
    
    PGraphics getOutByNo(int no) \{
        return outs\[no\];
    \}
    
    PImage getInByNo(int no) \{
        return ins\[no\];
    \}
    
    static class InOut \{
        final PImage in;
        final PGraphics out;
        
        InOut(PImage in, PGraphics out) \{
            this.in = in;
            this.out = out;
        \}
    \}
    
    static class Cell extends InOut \{
        final int no;
        
        Cell(PImage in, PGraphics out, int no) \{
            super(in, out);
            this.no = no;
        \}
    \}
    
    static class Colour \{
        final double r, g, b;
        
        Colour(double r, double g, double b) \{ 
            this.r=r; 
            this.g=g; 
            this.b=b; 
        \}
    \}
    
    Colour randomColour() \{ 
        return new Colour(random(255), random(255), random(255));
    \}
"
  }
  @ ./capture-1 video:capture {
    #%graph.x 119
    #%graph.y 701
    .device 2
    .resize-mode Crop
    .align-x 0.5887096774193549
    .align-y 0.0
    .zoom 1.8509600756236193
  }
  @ ./color video:custom {
    #%graph.x 124
    #%graph.y 207
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 37.016129032258064
    .green 205.64516129032256
    .blue 185.08064516129033
  }
  @ ./color1 video:custom {
    #%graph.x 418
    #%graph.y 59
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 121.33064516129033
    .green 217.98387096774195
    .blue 164.51612903225805
  }
  @ ./color2 video:custom {
    #%graph.x 119
    #%graph.y 365
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 187.13709677419357
    .green 84.31451612903226
    .blue 176.85483870967744
  }
  @ ./player-1 video:player {
    #%graph.x 361
    #%graph.y 518
    .video [file "resources/horse.mp4"]
    .position 0.12167149209427434
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x 540
    #%graph.y 671
  }
  @ ./color3 video:custom {
    #%graph.x 114
    #%graph.y 530
    .code "

    @P(1) @Type.Number(def=100, min=0, max=255) double red;
    @P(2) @Type.Number(def=100, min=0, max=255) double green;
    @P(3) @Type.Number(def=100, min=0, max=255) double blue;
    
    @Override
    public void setup() \{
        noStroke();
    \}
    
    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
"
    .red 255.0
    .green 255.0
    .blue 67.86290322580645
  }
  @ ./gl-gradients video:gl:p2d {
    #%graph.x 1044
    #%graph.y 719
    .code "

    @P(1)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double x;
    @P(2)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double y;
    @P(3)
    @Config.Port(false)
    boolean mouseInput;

    void updateUniforms() \{
        shader.set(\"time\", millis() / 1000.0);
        if (mouseInput) \{
            x = (double) mouseX / width;
            y = 1.0 - ((double) mouseY / height);
        \}
        shader.set(\"mouse\", x, y);
    \}

    // BOILERPLATE BELOW
    @P(0)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEF_FRAG)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    final String DEF_FRAG
            = \"uniform float time;\\n\"
            + \"uniform vec2 mouse;\\n\"
            + \"uniform vec2 resolution;\\n\"
            + \"\\n\"
            + \"void main() \{\\n\"
            + \"    // fragment position\\n\"
            + \"    vec2 pos = gl_FragCoord.xy/resolution.xy;\\n\"
            + \"    vec2 dist = mouse - pos;\\n\"
            + \"    vec3 white = vec3(1.0 - length(dist));\\n\"
            + \"    gl_FragColor = vec4(white, 1.0);\\n\"
            + \"\}\";

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER,
                    fragment.isEmpty() ? DEF_FRAG : fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}

"
    .fragment "uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main() \{
    vec2 pos = ( gl_FragCoord.xy / resolution.xy ) * 8.0 - 13.0;
    float x = sin(time*4 + length(pos.xy));
    float y = cos(time*18 + length(pos.xy));
    float white = x * y * 3.5;
    gl_FragColor = vec4(white, white, white, 1.0 );
\}"
    .x 0.0
    .y 1.0
    .mouse-input true
  }
  ~ ./voronoi-composite!out ./screen!in
}
