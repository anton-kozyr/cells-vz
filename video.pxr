@ /video root:video {
  #%autostart true
  #%praxis.version 4.1.1
  .renderer OpenGL
  .width 800
  .height 600
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 1952
    #%graph.y 181
    .always-on-top true
    .show-cursor true
  }
  @ ./player-1 video:player {
    #%graph.x 614
    #%graph.y 31
    .video [file "resources/horse.mp4"]
    .position 0.3036692330119161
  }
  @ ./custom-1 video:custom {
    #%graph.x 537
    #%graph.y 1157
    .code "import java.nio.file.Paths;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;


    @P(1) float\[\] fft;
    float max = 0.187f; // found by experiment
    
    @Override
    public void setup() \{

    \}
    
    @Override
    public void draw() \{
//        log(ERROR, \"\" +fft.length);
        if (fft.length == 0) \{
            return;
        \}
        blendMode(BLEND);
        float avg = Math.abs(fft\[fft.length/2\]);
        for(int i = fft.length/2; i<fft.length; ++i) \{
            float c = Math.abs(fft\[i\]);
            avg = (avg + c)/2;
        \}
        float f = (avg/max*100.0f);
//        log(ERROR, \"AVG: \"+f);
        fill(Math.min(255f*f, 255f), 0, 0);
        rect(0, 0, width, height);
    \}
            
"
    .fft "rO0ABXVyAAJbRgucgYki4AxCAgAAeHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  }
  @ ./start-trigger-1 core:start-trigger {
    #%graph.x 245
    #%graph.y 347
  }
  @ ./cells-4 video:custom {
    #%graph.x 1722
    #%graph.y 31
    .code "

    @In(1) PImage in1;
    @In(2) PImage in2;
    @In(3) PImage in3;
    @In(4) PImage in4;
    
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out1;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out2;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out3;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out4;
    
    @P(1) double xc = width/2;
    @P(2) double yc = height/2;
    
    @P(7) double h = height/2;
    
    @Override
    public void setup() \{
        xc = width/2;
        yc = height/2;
    \}
    
    @In(5)
    public void moveHorisontalSplit(double value) \{
        yc = height/2*(1 + value);
    \}
    
    @In(6)
    public void moveVeticalSplit(double value) \{
        xc = width/2*(1 + value);
    \}

    private double updateCoordInLimitsRandomly(double current, double min, double max) \{
        double i = 2;
        double delta = random(-i, i);
        if(delta + current > max) return current - delta;
        else if (delta + current < min) return current - delta;
        else return current + delta;
    \}

    private double updateCoordInLimits(double delta, double current, double min, double max) \{
        if(delta + current > max) return current - delta;
        else if (delta + current < min) return current - delta;
        else return current + delta;
    \}
    
    @Override
    public void draw() \{
        double xc = this.xc;
        double yc = this.yc;
        maskedImage(in1, out1, 0, 0, xc, yc);
        maskedImage(in2, out2, xc, 0, width-xc, yc);
        maskedImage(in3, out3, 0, yc, xc, height-yc);
        maskedImage(in4, out4, xc, yc, width-xc, height-yc);
        h = height/2;
    \}
    
    private void maskedImage(PImage in, PGraphics out, double x, double y, double w, double h) \{
        out.noStroke();
        out.blendMode(BLEND);
        out.fill(255);
        out.rect(x, y, w, h);
        out.blendMode(MULTIPLY);
        out.image(in, 0, 0);
        blendMode(ADD);
        copy(out);
        release(out);
    \}
/* Help from Neil:
    
    @In(1) PImage in1;
    @In(2) PImage in2;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out1;
    @OffScreen(format = OffScreen.Format.ARGB, persistent = false) PGraphics out2;

    @P(1) Property division;

    @Override
    public void setup() \{
        out1.noStroke();
        out2.noStroke();
        out1.background(0, 0);
        out2.background(0, 0);
    \}

    @Override
    public void draw() \{

        double div = d(division);

        // show only left half of first input
//        out1.clear();
        out1.blendMode(BLEND);
        out1.rect(0, 0, div * width, height);
        out1.blendMode(BlendMode.Mask);
        out1.image(in1, 0, 0);

        // shod only right half of second input
//        out2.clear();
        out2.blendMode(BLEND);
        out2.rect(div * width, 0, width, height);
        out2.blendMode(BlendMode.Mask);
        out2.image(in2, 0, 0);

        image(out1, 0, 0);

        // Next overrides everything rendered by out2
        // As a result left half - black rectangle, right half - right part
        // of second input (as expected)
        image(out2, 0, 0);
    \}

    @T(1) void trigger() \{
        division.to(random(0,1)).in(1).easeInOut();
    \}    
    */    
"
    .xc 280.4636322729348
    .yc 371.79299953306565
    .h 300.0
  }
  @ ./capture-1 video:capture {
    #%graph.x 608
    #%graph.y 496
    .device 1
    .zoom 1.0146823948778643
  }
  @ ./noise-1 video:source:noise {
    #%graph.x 1013
    #%graph.y 181
  }
  @ ./circles video:custom {
    #%graph.x 1248
    #%graph.y 367
    .code "

    @P(1) int count;
            
    LinkedList<Circle> l = new LinkedList<>();
    
    @Override
    public void setup() \{
        noStroke();
        for(int i = 0; i<count; ++i) \{
            l.add(new Circle());
        \}
    \}
    
    @In(1)
    public void addCircle(double ignored) \{
        l.add(new Circle());
        l.removeFirst();
    \}
    
    @Override
    public void draw() \{
        l.stream().forEach(Circle::draw);
    \}
    
    private class Circle \{
        private double x;
        private double y;
        private double d;
        private double r;
        private double g;
        private double b;
        
        public Circle() \{
            x = random(width);
            y = random(width);
            d = 50 + random(150);
            r = randomColor();
            g = randomColor();
            b = randomColor();
        \}
        
        private double randomColor() \{
            return 100 + random(155);
        \}
        
        public void draw() \{
            fill(r, g, b);
            ellipse(x, y, d, d);
        \}
    \}
"
    .count 10
  }
  @ ./timer-1 core:timing:timer {
    #%graph.x 1015
    #%graph.y 367
    .period 0.1
  }
  @ ./timer-2 core:timing:timer {
    #%graph.x 1015
    #%graph.y 568
    .period 5
  }
  @ ./animator-2 core:timing:animator {
    #%graph.x 1248
    #%graph.y 568
    .code "

    @T(0)
    void randomise() \{
        to = random(minValue, maxValue);
        toChanged();
    \}
    
    @P(1) @Type.Number @Transient
    double to;
    
    @P(2) @Type.Number @OnChange(\"valueChanged\")
    Property value;
    
    @P(3) @Type.Number(min = 0, max = 60, def = 0)
    double time;
    
    @P(4) @Type.Number(def = -1)
    double minValue;
    
    @P(5) @Type.Number(def = 1)
    double maxValue;
    
    @Out(1) Output out;
    boolean active;

    @Override
    public void update() \{
        if (value.isAnimating()) \{
            out.send(d(value));
            active = true;
        \} else if (active) \{
            out.send(to);
            active = false;
        \}
    \}
    
    void toChanged() \{
        value.to(to).in(time);
        active = true;
    \}
    
    void valueChanged() \{
        to = d(value);
        active = false;
        out.send(to);
    \}
    
"
    .value 0.24025691346030328
    .time 10
  }
  @ ./timer-4 core:timing:timer {
    #%graph.x 1015
    #%graph.y 809
    .period 6
  }
  @ ./animator-3 core:timing:animator {
    #%graph.x 1248
    #%graph.y 809
    .code "

    @T(0)
    void randomise() \{
        to = random(minValue, maxValue);
        toChanged();
    \}
    
    @P(1) @Type.Number @Transient
    double to;
    
    @P(2) @Type.Number @OnChange(\"valueChanged\")
    Property value;
    
    @P(3) @Type.Number(min = 0, max = 60, def = 0)
    double time;
    
    @P(4) @Type.Number(def = -1)
    double minValue;
    
    @P(5) @Type.Number(def = 1)
    double maxValue;
    
    @Out(1) Output out;
    boolean active;

    @Override
    public void update() \{
        if (value.isAnimating()) \{
            out.send(d(value));
            active = true;
        \} else if (active) \{
            out.send(to);
            active = false;
        \}
    \}
    
    void toChanged() \{
        value.to(to).in(time);
        active = true;
    \}
    
    void valueChanged() \{
        to = d(value);
        active = false;
        out.send(to);
    \}
    
"
    .value -0.2999895563608961
    .time 10
  }
  ~ ./start-trigger-1!out ./player-1!play
  ~ ./timer-1!out ./circles!add-circle
  ~ ./start-trigger-1!out ./capture-1!play
  ~ ./cells-4!out ./screen!in
  ~ ./timer-2!out ./animator-2!randomise
  ~ ./animator-2!out ./cells-4!move-horisontal-split
  ~ ./timer-4!out ./animator-3!randomise
  ~ ./animator-3!out ./cells-4!move-vetical-split
  ~ ./player-1!out ./cells-4!in-1
  ~ ./noise-1!out ./cells-4!in-2
  ~ ./capture-1!out ./cells-4!in-3
  ~ ./circles!out ./cells-4!in-4
}
